{"id":"rival-0wx","title":"Fix cancellation race - cancelled workflows can finish as completed","description":"cancel() sets status to 'cancelled' in workflow-coordinator.ts:213, but run() never checks cancelled state inside its execution loop and unconditionally sets 'completed' at the end (line 181).\n\nResult: cancelled workflows can finish as 'completed', defeating the purpose of cancellation.\n\nFix: Check c.state.status === 'cancelled' at the top of each iteration in the plan execution loop. Break out and return {status: 'cancelled'} if detected.\n\nFiles: src/rival/core/workflow-coordinator.ts\nFound by: Codex review\nSeverity: High","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:08.12199-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:08.12199-06:00","labels":["bug","high-priority"]}
{"id":"rival-19f","title":"Rename plan field actorType -\u003e actorName (no deprecation)","description":"Context:\nProject is greenfield/unreleased. Current plan node field  is confusing and reads like a TypeScript type rather than a runtime actor registry key.\n\nDecision:\nRename  to  everywhere with no backward-compat/deprecation layer.\n\nScope:\n1) Types/schema\n- Update StepPlanNode in src/rival/types/plan.ts from  to .\n- Update Zod schema validation keys and related plan docs/comments.\n\n2) Compiler\n- In src/rival/builder/compiler.ts, emit  in plan nodes.\n- Keep generated actor registry key format unchanged unless separately scoped.\n\n3) Runtime\n- In src/rival/core/workflow-coordinator.ts, resolve step actor via .\n- Update all error messages/log text to reference actor name consistently.\n\n4) Tests\n- Update all tests constructing plan nodes manually (phase1 and any others) to use .\n- Update assertions/messages that mention actorType.\n\n5) Public API/docs/comments\n- Update src/rival/index.ts examples and any inline docs to use .\n- Ensure no remaining  references in src/test docs.\n\nAcceptance criteria:\n- Zero occurrences of  in src/test (except potential historical changelog notes).\n- Build/typecheck passes.\n- Existing tests pass with renamed field.\n- Public examples use .","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-08T22:26:52.306011-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:52:35.070159-06:00","closed_at":"2026-02-08T22:52:35.070159-06:00","close_reason":"Closed"}
{"id":"rival-43z","title":"Introduce explicit coordinator state machine","description":"Problem:\nCoordinator orchestration is currently an implicit state machine spread across action code paths. It works, but transition logic is not explicit, making behavior harder to reason about, review, and extend.\n\nGoal:\nIntroduce an explicit, official state machine model for workflow coordination.\n\nDesired outcome:\n- States and legal transitions are declared centrally (single source of truth).\n- Actions perform validated transitions through that state machine.\n- Transition side effects (scheduling, completion reporting, timestamps, error fields) are deterministic and testable.\n\nScope:\n1) State model\n- Define explicit state enum and transition map/table.\n- Include at minimum: pending, running, completed, failed, cancelled.\n- Include transition events (e.g., START, STEP_SUCCESS, STEP_FAILURE, CANCEL, FINISH, INTERNAL_ERROR).\n\n2) Transition engine\n- Add transition helper(s) that validate legal transitions and apply state mutations atomically.\n- Reject/ignore invalid transitions with clear diagnostics.\n\n3) Coordinator integration\n- Refactor start/processNextStep/cancel to use transition helper instead of ad hoc mutation.\n- Ensure scheduling and completion callbacks are tied to explicit transition outcomes.\n\n4) Observability\n- Add optional transition log entries (fromState -\u003e event -\u003e toState) for debugging.\n\n5) Tests\n- Transition matrix tests (legal and illegal transitions).\n- End-to-end workflow tests covering success/failure/cancel.\n- Regression tests for double-finalization and duplicate tick handling.\n\n6) Docs\n- Add concise state diagram/transition table to docs/comments.\n- Explain how to add new states/events safely.\n\nAcceptance criteria:\n- Coordinator state changes only via explicit transition path.\n- Illegal transitions are blocked and tested.\n- Existing workflow behavior preserved (except intended clarifications).\n- State model is documented and easy for contributors to follow.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-08T22:38:20.854931-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:38:20.854931-06:00"}
{"id":"rival-4pz","title":"Hide compile step from public workflow DX","description":"Problem:\nCurrent public API requires users to call createWorkflow(...).build() and then compileWorkflow(...). This is perceived as leaky internals and poor DX.\n\nGoal:\nMake workflow authoring a single high-level flow where compilation is implicit/hidden from normal users.\n\nDesired outcome:\n- Typical usage does not require importing or calling compileWorkflow.\n- Builder path returns a runnable/registrable artifact directly (or via explicit high-level terminal method that is not named compile).\n- Existing low-level compile primitives can remain internal/advanced, but should not be the default documented API.\n\nScope:\n1) API redesign:\n   - Introduce a primary fluent terminal path that hides compilation.\n   - Decide compatibility strategy for existing .build() behavior (deprecate or alias strategy).\n2) Runtime wiring:\n   - Ensure resulting object can be directly registered with setup/use and registry helpers.\n3) Docs/examples:\n   - Update all public examples to new primary path.\n   - Move compileWorkflow to advanced section only (or internal).\n4) Tests:\n   - Add tests proving zero explicit compile call in standard usage.\n   - Keep backward-compat tests if old API remains temporarily.\n\nAcceptance criteria:\n- A new user can define and run a workflow without ever seeing compileWorkflow.\n- Existing examples in src/rival/index.ts comments and tests reflect hidden-compile DX.\n- Migration notes provided for previous API if behavior changed.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-08T22:17:36.786251-06:00","created_by":"behrooz","updated_at":"2026-02-08T23:15:49.112574-06:00"}
{"id":"rival-5tw","title":"Enforce unique step names at builder/compile time","description":"Duplicate step names silently corrupt execution. Actor names are generated as {workflow}_{stepName} in compiler.ts:41 - duplicates overwrite actor entries. At runtime, workflow-coordinator.ts:142 reuses the same key for step instances.\n\nResult: step collisions, wrong actor/function execution, state bleed across nodes.\n\nFix: Add validation in WorkflowBuilder.step() and/or compileWorkflow() to reject duplicate step names with a clear error message.\n\nFiles: src/rival/builder/workflow-builder.ts, src/rival/builder/compiler.ts\nFound by: Codex review\nSeverity: High","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:02.36434-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:49:25.684771-06:00","closed_at":"2026-02-08T20:16:07.370147-06:00","close_reason":"Closed","labels":["bug","high-priority"]}
{"id":"rival-90s","title":"Replace console.log with pino logger in workflow-coordinator","description":"The coordinator uses raw console.log for all logging (9 call sites in src/rival/core/workflow-coordinator.ts). Should use pino like the step actors do via createStepLogger. Need to wire up a coordinator-level logger variant and replace all console.log calls.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T18:44:30.984414-06:00","created_by":"behrooz","updated_at":"2026-02-08T18:44:30.984414-06:00","labels":["enhancement"]}
{"id":"rival-988","title":"Reset stale error metadata on workflow rerun","description":"run() in workflow-coordinator.ts resets some fields (status, input, stepResults, currentStepIndex) but not error, failedStep, or completedAt before starting execution (line 90 onward).\n\nResult: getState() may expose stale failure details from a previous run after a successful rerun.\n\nFix: Reset error=null, failedStep=null, completedAt=null at the start of run().\n\nFiles: src/rival/core/workflow-coordinator.ts\nFound by: Codex review\nSeverity: Medium","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:20.306328-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:20.306328-06:00","labels":["bug"]}
{"id":"rival-a7h","title":"Local/function-only execution mode","description":"Add an opt-in mode where workflows execute as plain function calls without the Rivet actor model. Same builder API, same StepContext, retries, timeouts, logging, and result threading — but steps are called directly as functions instead of going through actor getOrCreate/execute. Removes RivetKit dependency for simple single-process pipelines.\n\nKey design points:\n1. Retry/timeout logic moves from step-actor into a lightweight runner/executor\n2. Same WorkflowDefinition from builder compiles to a different backend\n3. forEach parallel uses Promise.all directly\n4. Could be a flag on rival() like { mode: \"local\" } or a separate entry point like rivalLocal()\n\nTradeoff: no actor state persistence, no distributed coordination, no external inspect/resume — but much simpler for straight-through pipelines.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-11T20:31:28.002548-06:00","created_by":"behrooz","updated_at":"2026-02-11T20:31:28.002548-06:00","labels":["feature"]}
{"id":"rival-aox","title":"Implement timeout, onTimeout, and onError in StepConfig","description":"StepConfig defines timeout, onTimeout, and onError (src/rival/types/step.ts:18-31) but createStepActor only uses maxAttempts and backoff (step-actor.ts:78). WorkflowDefinition.onError (workflow.ts:21) is also never used by compiler or coordinator.\n\nThe API promises behavior the runtime does not implement. Either implement these features or remove/deprecate them from the types until they are.\n\nFiles: src/rival/core/step-actor.ts, src/rival/core/workflow-coordinator.ts, src/rival/builder/compiler.ts, src/rival/types/step.ts\nFound by: Codex review\nSeverity: High","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:14.475224-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:14.475224-06:00","labels":["enhancement","high-priority"]}
{"id":"rival-fpk","title":"Expose full runtime/workflow configuration + raw actor ergonomics","description":"Context: Rival currently exposes StepConfig in types/builder, but coordinator execution still uses a hardcoded step timeout and does not consistently honor per-step timeout/onTimeout precedence. Also actor-level Rivet options (e.g., actionTimeout and related options) are not passed through factory APIs.\n\nGoal:\nMake configuration as fully exposed as possible while keeping sane defaults, and ensure advanced users can use raw actors without fighting abstractions.\n\nScope:\n1) Wire timeout precedence in coordinator execution:\n   - step config timeout \u003e workflow default step timeout \u003e coordinator fallback.\n   - implement onTimeout behavior (stop/retry; optionally continue if added).\n2) Expose factory-level options passthrough:\n   - createStepActor(..., options?)\n   - createWorkflowCoordinator(..., options?)\n   - createRegistryActor(..., options?)\n   where options can include Rivet actor options and Rival-specific defaults.\n3) Keep raw-actor usage first-class:\n   - document direct setup({ use: ... }) with compiled actors/factories.\n   - ensure no internal assumptions block direct actor registration.\n4) Tests:\n   - per-step timeout honored.\n   - precedence order behavior.\n   - onTimeout stop/retry behavior.\n   - factory option passthrough compiles and works.\n5) Docs/examples:\n   - show simple mode and advanced/raw actor mode.\n\nOut of scope:\n- New orchestration DSL features (branch/loop/parallel semantics redesign).\n\nAcceptance criteria:\n- No hardcoded-only timeout path for step execution.\n- Public API exposes configuration knobs for advanced users.\n- Existing simple usage remains ergonomic and backward compatible where practical.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-08T21:59:57.999553-06:00","created_by":"behrooz","updated_at":"2026-02-08T21:59:57.999553-06:00"}
{"id":"rival-hrd","title":"[EPIC] Actor-native retry/timeout migration with phased rollout","description":"Epic for migrating actor-mode execution to scheduled retries/timeouts with phased, agent-delegable deliverables.\n\nPlan doc: docs/plans/rival-hrd.md\n\n## Phase Breakdown\n1. Phase 1: Step actor scheduled retry/timeout core\n2. Phase 2: Coordinator async progression (top-level only; loops remain sync)\n3. Phase 3: Engine API transition to run + wait\n4. Phase 4: Full async loop continuation state machine (deferred)\n5. Phase 5: Event-driven wait optimization (deferred)\n\n## Scope\n- Actor runtime correctness and responsiveness between retries\n- Timeout enforcement in scheduled action model\n- Clear phased boundaries to allow parallel delegation and review\n\n## Out of Scope (for early phases)\n- Full async loop continuation in phase 1-3\n- Replacing polling wait with events before baseline stability\n","status":"in_progress","priority":2,"issue_type":"epic","created_at":"2026-02-11T20:42:31.624786-06:00","created_by":"behrooz","updated_at":"2026-02-11T22:26:43.931887-06:00","labels":["bug"]}
{"id":"rival-hrd.1","title":"[Phase 1] Step actor scheduled retry/timeout core","description":"Implement scheduled retry/timeout in step actor with persisted callback address and token-guarded internal actions. Greenfield: allow breaking API changes that support async-first execution model.","acceptance_criteria":"No sleep() retry loop remains; retries use c.schedule.after. Add waiting_retry status, timeout scheduling, maxAttempts cap, coordinatorRef/coordinatorKey persistence, and step-level onError on terminal failure. Add schedule-focused tests using Vitest fake timers.","notes":"Implemented async-first step actor kickoff with scheduled _attempt/_onTimeout actions, persisted execution metadata (including coordinatorRef/coordinatorKey), waiting_retry status, retry max cap, explicit saveState before scheduling retries, and terminal step-level onError. Added schedule-focused tests in test/step-actor-scheduling.test.ts (passing). Coordinator temporarily polls step terminal state via getTerminalResult until Phase 2 callback-driven progression lands.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-11T22:27:08.230641-06:00","created_by":"behrooz","updated_at":"2026-02-11T23:21:32.862224-06:00","closed_at":"2026-02-11T23:21:32.862224-06:00","close_reason":"Closed","labels":["actor","bug","retry"],"dependencies":[{"issue_id":"rival-hrd.1","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T22:27:08.231873-06:00","created_by":"behrooz"}]}
{"id":"rival-hrd.2","title":"[Phase 2] Coordinator async progression (loops stay sync)","description":"Make top-level coordinator non-blocking with callback-driven progression. Keep forEach/loop body orchestration synchronous in this phase (Option C scope lock).","acceptance_criteria":"run() kickoff is non-blocking and progression advances via continuation actions/callbacks. Workflow cancel and failure paths remain correct. Loop behavior remains functionally equivalent and synchronous internally.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-11T22:27:18.584251-06:00","created_by":"behrooz","updated_at":"2026-02-12T00:15:25.132499-06:00","closed_at":"2026-02-12T00:15:25.132499-06:00","close_reason":"Closed","labels":["actor","coordinator"],"dependencies":[{"issue_id":"rival-hrd.2","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T22:27:18.585225-06:00","created_by":"behrooz"}],"comments":[{"id":2,"issue_id":"rival-hrd.2","author":"behrooz","text":"External review findings to drive Phase 2 implementation\n\nCritical findings\n1) Coordinator run() blocks for entire workflow duration.\n2) Coordinator uses polling loop (`sleep(25)`) for step completion.\n3) Dead callback path: step actor emits `notifyCoordinator()`, but coordinator lacks `onStepFinished` continuation action.\n\nImplications\n- Step actor side appears ready.\n- Coordinator side is the remaining gap for event-driven, non-blocking progression.\n\nPhase 2 checklist update\n- Add coordinator action `onStepFinished(...)` as callback ingress.\n- Refactor run() to kickoff-only (non-blocking), persist execution frame, and return running state quickly.\n- Remove terminal polling loop and sleep-based waiting from coordinator path.\n- Drive progression from callback/continuation actions.\n- Preserve Option C scope lock: top-level async progression, loop internals still synchronous.\n\nDefinition-of-done additions\n- No `sleep(...)`/polling loop remains in coordinator progression.\n- Callback path is live end-to-end: step actor callback -\u003e coordinator continuation -\u003e workflow completion.\n- Existing step actor scheduled retry/timeout behavior remains unchanged and passing.\n","created_at":"2026-02-12T05:16:31Z"}]}
{"id":"rival-hrd.3","title":"[Phase 3] Engine API transition to run + wait","description":"Introduce start-and-wait model in engine/instance APIs while preserving clear terminal result semantics.","acceptance_criteria":"engine.run returns start metadata {runId,status}; engine.wait and instance.wait are implemented with timeoutMs default 300000 and pollIntervalMs default 250. Docs and tests updated for new API.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-11T22:27:28.904966-06:00","created_by":"behrooz","updated_at":"2026-02-12T00:52:52.191733-06:00","closed_at":"2026-02-12T00:52:52.191733-06:00","close_reason":"Closed","labels":["api","engine"],"dependencies":[{"issue_id":"rival-hrd.3","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T22:27:28.906026-06:00","created_by":"behrooz"}]}
{"id":"rival-hrd.4","title":"[Phase 4] Full async loop continuation state machine (deferred)","description":"Design and implement full continuation state machine for sequential/parallel/nested loop execution under async coordinator model.","acceptance_criteria":"Loop continuation state machine is decision-complete and implemented with tests for sequential, parallel fan-out/fan-in, nested loops, cancellation, and failure semantics.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-02-11T22:27:39.162574-06:00","created_by":"behrooz","updated_at":"2026-02-12T00:53:02.468358-06:00","closed_at":"2026-02-12T00:53:02.468358-06:00","close_reason":"Closed","labels":["deferred","loop"],"dependencies":[{"issue_id":"rival-hrd.4","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T22:27:39.163562-06:00","created_by":"behrooz"}]}
{"id":"rival-hrd.5","title":"[Phase 5] Event-driven wait optimization (deferred)","description":"Add event/subscription-driven wait path (broadcast-based) to reduce polling overhead while retaining polling fallback.","acceptance_criteria":"wait can use broadcast/subscription path when available and falls back to polling. Include behavior docs and tests for both paths.","status":"open","priority":3,"issue_type":"chore","created_at":"2026-02-11T22:27:49.441722-06:00","created_by":"behrooz","updated_at":"2026-02-11T22:27:49.441722-06:00","labels":["deferred","perf","wait"],"dependencies":[{"issue_id":"rival-hrd.5","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T22:27:49.442851-06:00","created_by":"behrooz"}]}
{"id":"rival-hrd.6","title":"Review timeout alignment: step actor actionTimeout vs user step timeout","description":"Investigate and decide timeout model for step execution. Evaluate whether step actor actionTimeout should be set from user-provided step timeout, and how that interacts with Rivet action timeout limits, scheduler-based _onTimeout, retries, and long-running user functions. Produce implementation guidance and acceptance criteria for greenfield behavior (no backward compatibility constraints).","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-11T23:02:44.843405-06:00","created_by":"behrooz","updated_at":"2026-02-11T23:45:11.766446-06:00","closed_at":"2026-02-11T23:45:11.766446-06:00","close_reason":"Closed","dependencies":[{"issue_id":"rival-hrd.6","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T23:02:44.844349-06:00","created_by":"behrooz"}]}
{"id":"rival-jg6","title":"Dead/dormant code audit cleanup (runtime + API surface)","description":"Audit summary (strict static pass):\n\nHigh-confidence dead behavior (implemented surface, no runtime effect):\n1) StepConfig.onTimeout is accepted by builder/types but not used by runtime execution.\n   - src/rival/types/step.ts:26\n   - src/rival/builder/workflow-builder.ts:89\n2) StepConfig.onError is accepted by builder/types but never invoked.\n   - src/rival/types/step.ts:30\n   - src/rival/builder/workflow-builder.ts:91\n3) WorkflowDefinition.onError is captured but not consumed by coordinator/registry runtime.\n   - src/rival/types/workflow.ts:23\n   - src/rival/builder/workflow-builder.ts:106\n\nDormant feature surface (declared but intentionally skipped):\n4) Plan node types Branch/Loop/Parallel/Workflow are modeled but coordinator skips non-step nodes.\n   - src/rival/types/plan.ts:28\n   - src/rival/types/plan.ts:43\n   - src/rival/types/plan.ts:56\n   - src/rival/types/plan.ts:67\n   - src/rival/core/workflow-coordinator.ts:155\n\nLikely unused API exports in-repo (may be external-facing):\n5) createEmptyStepState export appears unused in-repo.\n   - src/rival/core/context-builder.ts:45\n   - src/rival/index.ts:47\n6) WorkflowExecutionResult appears export-only now.\n   - src/rival/core/workflow-coordinator.ts:42\n   - src/rival/index.ts:43\n7) WorkflowRunInfo appears export-only in-repo.\n   - src/rival/types/workflow.ts:62\n   - src/rival/index.ts:80\n8) StepMetrics appears export-only in-repo.\n   - src/rival/types/step.ts:72\n   - src/rival/index.ts:66\n9) workflowRegistry/registerWorkflow exported but not used by current tests/primary flow.\n   - src/rival/core/registry-actor.ts:96\n   - src/rival/core/registry-actor.ts:445\n\nEstimated impact:\n- Dead/dormant footprint in src: ~120-220 LOC (~5-10% of src).\n\nCleanup plan required in this issue:\nA) Safe remove now (non-breaking internal)\n- Remove/trim truly internal unused helpers and stale comments.\n- Keep behavior unchanged for public APIs.\n\nB) Deprecate-first (public surface)\n- For exported-but-unused types/functions, add @deprecated + migration notes first.\n- Remove in next major only if no external usage is confirmed.\n\nC) Runtime alignment (preferred)\n- Either wire onTimeout/onError/onError(workflow) into runtime semantics OR remove from public config to avoid misleading API.\n\nAcceptance criteria:\n1) No config field is accepted by builder/types without documented runtime behavior.\n2) Non-step plan node support is either implemented or clearly marked as unsupported in public API/docs (not implied as available).\n3) Public exports have deprecation policy applied where removal is planned.\n4) Docs/examples align with actual implemented behavior.\n5) Add tests that lock behavior for whichever path is chosen (wire-in vs remove/deprecate).","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T22:21:12.30011-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:21:12.30011-06:00"}
{"id":"rival-kr3","title":"Implement branch/loop/parallel execution in coordinator","description":"Plan types for BranchPlanNode, LoopPlanNode, and ParallelPlanNode are defined in types/plan.ts but the coordinator only handles type='step' nodes. There's a TODO comment at workflow-coordinator.ts:111.\n\nThis is the main feature gap for making Rival a full workflow engine. Needs:\n- BranchSupervisor: evaluate condition actor, execute then/else path\n- LoopSupervisor: execute body repeatedly until condition is false  \n- ParallelSupervisor: spawn all children concurrently, await all results\n\nFiles: src/rival/core/workflow-coordinator.ts, src/rival/types/plan.ts\nFrom: redesign.md design spec\nSeverity: Feature - Future phase","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:43.023879-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:43.023879-06:00","labels":["enhancement","feature"],"dependencies":[{"issue_id":"rival-kr3","depends_on_id":"rival-qr7","type":"blocks","created_at":"2026-02-08T12:31:01.771712-06:00","created_by":"behrooz"},{"issue_id":"rival-kr3","depends_on_id":"rival-0wx","type":"blocks","created_at":"2026-02-08T12:31:01.863692-06:00","created_by":"behrooz"},{"issue_id":"rival-kr3","depends_on_id":"rival-aox","type":"blocks","created_at":"2026-02-08T12:31:01.95467-06:00","created_by":"behrooz"}]}
{"id":"rival-lap","title":"Build Rival Engine - standalone executable with UI","description":"The two-tier vision has Rival Library (done) and Rival Engine (not started). The engine would be a standalone executable with a web UI for:\n\n- Workflow monitoring dashboard\n- Live step execution visualization\n- Log viewing (mockups exist in mockups/ui-mockup-logs.html)\n- Workflow launching and management\n- Nested workflow visualization (mockups/ui-mockup-nested.html)\n\nUI mockups already exist in mockups/ directory. Plan AST is already serializable for UI consumption. WebSocket integration was explored in earlier commits.\n\nFiles: mockups/\nFrom: redesign.md, .claude/RIVAL.md\nSeverity: Feature - Future phase","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:50.457537-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:50.457537-06:00","labels":["enhancement","feature"],"dependencies":[{"issue_id":"rival-lap","depends_on_id":"rival-kr3","type":"blocks","created_at":"2026-02-08T12:31:05.65873-06:00","created_by":"behrooz"},{"issue_id":"rival-lap","depends_on_id":"rival-u2e","type":"blocks","created_at":"2026-02-08T12:31:05.773266-06:00","created_by":"behrooz"}]}
{"id":"rival-mep","title":"Support remote/distributed Rivet runtime (horizontal execution)","description":"Rival currently runs local/in-process via setup({ use: ...actors }) + start({ disableDefaultServer: true }). This limits workflows to a single process and blocks intended Rivet horizontal distribution patterns.\\n\\nWhy this matters (P1):\\n- Production deployment should support remote actor runtime and horizontal scale.\\n- Workflows should execute across distributed Rivet actors rather than only local headless mode.\\n\\nGoal:\\n- Enable Rival engine to run against a remote/distributed Rivet runtime while preserving current local convenience mode.\\n\\nScope:\\n1) Engine modes\\n- Keep existing local mode () for DX/testing.\\n- Add remote mode (new API or options) that connects to a remote Rivet client/runtime.\\n\\n2) Registration/deployment model\\n- Decouple compile-time plan generation from local actor registration.\\n- Define how step actors/coordinator are published/registered for remote runtime.\\n\\n3) Actor refs + identity\\n- Ensure actor refs are deterministic and globally safe for distributed environments.\\n- Document namespace/encoding guarantees for remote lookup.\\n\\n4) Reliability semantics\\n- Define behavior for network failures, unavailable actor refs, retries, and timeout boundaries.\\n- Maintain workflow-level failure reporting consistency.\\n\\n5) Backward compatibility\\n- No regression for current local mode and existing API consumers.\\n\\n6) Tests/docs\\n- Integration tests for remote mode (including nested forEach and failure paths).\\n- Clear docs for local vs remote execution, deployment prerequisites, and migration notes.\\n\\nAcceptance criteria:\\n- Rival can run workflows against a remote/distributed Rivet runtime.\\n- Same workflow definition can be executed in local and remote modes.\\n- Core semantics (step/loop execution and failure behavior) stay consistent across modes.\\n- Local mode remains supported and unchanged by default.","status":"open","priority":1,"issue_type":"feature","created_at":"2026-02-11T20:06:20.21663-06:00","created_by":"behrooz","updated_at":"2026-02-11T20:06:20.21663-06:00","labels":["architecture","rivetkit","scalability"]}
{"id":"rival-o0p","title":"Function-call style step arguments + hidden compile DX","description":"Problem:\nWorkflow step authoring does not feel like normal function calls. Passing static step arguments is unintuitive (requires plan/config internals), and compile details leak into user-facing DX.\n\nGoal:\nExpose a function-call-like API where developers pass step arguments naturally, while compilation/actor internals remain hidden in the default path.\n\nTarget API shape (example):\n- defineWorkflow('lumber')\n    .step(findTree, { radius: 250, species: 'oak' })\n    .step(chopTree, { blade: 'A2' })\n    .run({ location: 'north-forest' })\n\nStep function ergonomics:\n- Support either  or  pattern (choose one and document clearly).\n- Args must be serializable.\n\nScope:\n1) Builder API\n- Add first-class step args on  in fluent API.\n- Keep simple no-args step path ergonomic.\n\n2) Runtime plumbing\n- Ensure step args flow through compile/runtime to step actor execute context predictably.\n- Do not require users to manually place arguments into plan config.\n\n3) Hidden compile defaults\n- Standard user path should never require explicit compileWorkflow call.\n- compile internals may remain for advanced usage but not default docs/examples.\n\n4) Typing\n- Preserve strong TS inference for step args and input where feasible.\n- Provide clear type errors for non-serializable args.\n\n5) Tests\n- Add tests for:\n  a) static args passed to step functions correctly\n  b) args + per-run input used together\n  c) no-args steps still work\n  d) serialization guard behavior\n\n6) Docs/examples\n- Rewrite primary examples to function-call style step args.\n- Explain mental model briefly: looks like functions, runs as actors.\n\nAcceptance criteria:\n- A new user can define workflow steps with arguments without touching plan internals.\n- Primary docs/examples show no explicit compile call.\n- Step argument passing is stable, typed, and covered by tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-08T22:35:07.120356-06:00","created_by":"behrooz","updated_at":"2026-02-08T23:36:50.919849-06:00","closed_at":"2026-02-08T23:36:50.919849-06:00","close_reason":"Scope expanded to universal executor architecture. Needs new bead with broader scope covering executor pattern + step args + fluent DX."}
{"id":"rival-qr7","title":"Fix StepError continue behavior - coordinator treats all failures as terminal","description":"StepError with behavior='continue' returns {status: 'failed'} from step-actor.ts:131, and workflow-coordinator.ts:155 treats ALL failed steps as terminal, stopping the workflow. The documented contract says 'continue' should let the workflow proceed past the failed step.\n\nFix: coordinator should check if the step failure originated from a StepError with behavior='continue' and proceed to the next step instead of stopping.\n\nFiles: src/rival/core/step-actor.ts, src/rival/core/workflow-coordinator.ts\nFound by: Codex review\nSeverity: High","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-08T12:29:56.188057-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:49:25.690511-06:00","closed_at":"2026-02-08T20:16:49.207244-06:00","close_reason":"Closed","labels":["bug","high-priority"]}
{"id":"rival-rms","title":"Allow reusing same step function without forcing unique explicit names","description":"Current behavior: .step(hello).step(hello) fails because inferred step names collide (\"hello\"). This was unexpected and not intended as a hard limitation.\\n\\nDesired behavior:\\n- Allow reusing the same function multiple times in a workflow without requiring manual names for each occurrence.\\n- Keep actor refs and plan node names deterministic and unique.\\n\\nPossible approaches:\\n1) Auto-disambiguate inferred duplicate names (hello, hello_2, hello_3, ...).\\n2) Keep strict unique names for explicit names, but make inferred names auto-unique only when omitted by user.\\n3) Preserve compatibility for existing workflows and error messages where user explicitly sets duplicates.\\n\\nAcceptance criteria:\\n- createWorkflow('w').step(hello).step(hello).build() succeeds.\\n- Compiled actor refs are unique and stable.\\n- Result access semantics are documented for auto-disambiguated names.\\n- Tests added for inferred duplicates and explicit-name duplicate rejection.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-11T19:39:20.463108-06:00","created_by":"behrooz","updated_at":"2026-02-11T19:39:20.463108-06:00","labels":["dx","workflow-builder"]}
{"id":"rival-roa","title":"Function-call style step arguments + hidden compile DX","description":"Problem:\nWorkflow step authoring does not feel like normal function calls. Passing static step arguments is unintuitive (requires plan/config internals), and compile details leak into user-facing DX.\n\nGoal:\nExpose a function-call-like API where developers pass step arguments naturally, while compilation/actor internals remain hidden in the default path.\n\nTarget API shape (example):\n- defineWorkflow('lumber')\n    .step(findTree, { radius: 250, species: 'oak' })\n    .step(chopTree, { blade: 'A2' })\n    .run({ location: 'north-forest' })\n\nStep function ergonomics:\n- Support either step(ctx, args) or ctx.args pattern (choose one and document clearly).\n- Args must be serializable.\n\nScope:\n1) Builder API\n- Add first-class step args on .step(...) in fluent API.\n- Keep simple no-args step path ergonomic.\n\n2) Runtime plumbing\n- Ensure step args flow through compile/runtime to step actor execute context predictably.\n- Do not require users to manually place arguments into plan config.\n\n3) Hidden compile defaults\n- Standard user path should never require explicit compileWorkflow call.\n- compile internals may remain for advanced usage but not default docs/examples.\n\n4) Typing\n- Preserve strong TS inference for step args and input where feasible.\n- Provide clear type errors for non-serializable args.\n\n5) Tests\n- Add tests for:\n  a) static args passed to step functions correctly\n  b) args + per-run input used together\n  c) no-args steps still work\n  d) serialization guard behavior\n\n6) Docs/examples\n- Rewrite primary examples to function-call style step args.\n- Explain mental model briefly: looks like functions, runs as actors.\n\nAcceptance criteria:\n- A new user can define workflow steps with arguments without touching plan internals.\n- Primary docs/examples show no explicit compile call.\n- Step argument passing is stable, typed, and covered by tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-08T22:35:26.930367-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:50:34.908932-06:00","closed_at":"2026-02-08T22:50:34.908932-06:00","close_reason":"Duplicate of rival-o0p"}
{"id":"rival-sm8","title":"Remove '__' naming ban and replace with robust actor-ref encoding","description":"Current builder behavior rejects step/loop names containing '__' because it is used as an internal namespace separator. This is an unexpected developer-facing limitation and should be removed.\\n\\nProblem:\\n- WorkflowBuilder._assertUniqueStepName currently throws if name contains '__'.\\n- This leaks internal implementation details into public API constraints.\\n\\nGoal:\\n- Allow arbitrary user step/loop names (including '__') while preserving deterministic, collision-safe actor refs and plan execution.\\n\\nImplementation direction:\\n1) Remove '__' ban from builder-level validation.\\n2) Introduce a robust actor-ref encoding scheme that does not rely on raw name concatenation (e.g., escaping, length-prefixed segments, or hash+metadata approach).\\n3) Keep refs deterministic across compile runs.\\n4) Preserve readability where possible (debug metadata/logs can show original names even if encoded refs are opaque).\\n5) Add migration/compat notes if actor-ref format changes impact persisted state.\\n\\nAcceptance criteria:\\n- Names with '__' are accepted in .step and .forEach.\\n- No actor ref collisions occur due to separators appearing in user names.\\n- Existing uniqueness checks still enforce semantic duplicate names per scope.\\n- Tests added for names containing '__' at top-level and nested loops.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-11T19:53:53.907513-06:00","created_by":"behrooz","updated_at":"2026-02-11T19:53:53.907513-06:00","labels":["compiler","dx","naming"]}
{"id":"rival-tuo","title":"Add if/conditional branch step","description":"Add conditional branching (if/else) to the workflow DSL. This allows workflows to take different paths based on runtime conditions — e.g., evaluating step outputs, state values, or expressions to decide which branch to execute next. Should integrate with the existing step orchestration and actor model patterns.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-10T11:10:57.041049-06:00","created_by":"behrooz","updated_at":"2026-02-10T11:10:57.041049-06:00"}
{"id":"rival-u2e","title":"Add comprehensive test coverage for missing semantics","description":"Current test suite misses critical semantic paths:\n\n- No tests for StepError.behavior === 'continue' (workflow should proceed)\n- No tests for duplicate step names (should error at build/compile time)\n- No tests for cancellation during execution (race condition)\n- No tests for workflow rerun with stale state\n- Tests are script-style (process.exit) rather than granular bun:test cases\n\nFix: Add focused test cases for each semantic gap. Consider migrating to bun test framework with describe/it/expect for better isolation and reporting.\n\nFiles: test/\nDepends on: rival-qr7, rival-5tw, rival-0wx, rival-988\nFound by: Codex review\nSeverity: Medium","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:35.543452-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:35.543452-06:00","labels":["enhancement","testing"],"dependencies":[{"issue_id":"rival-u2e","depends_on_id":"rival-qr7","type":"blocks","created_at":"2026-02-08T12:30:57.640795-06:00","created_by":"behrooz"},{"issue_id":"rival-u2e","depends_on_id":"rival-5tw","type":"blocks","created_at":"2026-02-08T12:30:57.740822-06:00","created_by":"behrooz"},{"issue_id":"rival-u2e","depends_on_id":"rival-0wx","type":"blocks","created_at":"2026-02-08T12:30:57.850232-06:00","created_by":"behrooz"},{"issue_id":"rival-u2e","depends_on_id":"rival-988","type":"blocks","created_at":"2026-02-08T12:30:57.945419-06:00","created_by":"behrooz"}]}
{"id":"rival-y5z","title":"Fix test environment - RivetKit EPERM on inspector token write","description":"Tests fail with EPERM when RivetKit tries to write inspector token to ~/Library/Application Support/rivetkit/.../inspector-token. This is the actual root cause of the test failures (not a c.client() API issue as initially suspected).\n\nTests pass when run with HOME=/tmp.\n\nFix: Configure test setup to override RivetKit storage path, or add a test helper that sets up a temp directory. This makes tests portable and CI-friendly.\n\nFiles: test/phase1.test.ts, test/phase2.test.ts, test/phase3.test.ts, test/phase4.test.ts\nFound by: Codex test run\nSeverity: Medium","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:28.199912-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:28.199912-06:00","labels":["bug","testing"]}
{"id":"rival-zpt","title":"Add loop step","description":"Add a loop step to the workflow; this appears to be missing and should be implemented/documented where the flow is defined.","notes":"Implementation requirement: match our existing workflow patterns using the actor model. The loop step should be orchestrated as actors that spin up, then advance to the next actor when completion messages return. Also support a fan-out/fan-in style mode (fire all, then collect/aggregate completions) where appropriate.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-09T23:09:25.281552-06:00","created_by":"behrooz","updated_at":"2026-02-09T23:11:30.286622-06:00"}
