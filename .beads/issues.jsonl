{"id":"rival-0t0","title":"Built-in data mapping/validation transform step","description":"Add declarative data transform/mapping step with schema validation/defaults to reduce bespoke mapping code between steps.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-12T11:15:36.462596-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:15:36.462596-06:00"}
{"id":"rival-0wx","title":"Fix cancellation race - cancelled workflows can finish as completed","description":"cancel() sets status to 'cancelled' in workflow-coordinator.ts:213, but run() never checks cancelled state inside its execution loop and unconditionally sets 'completed' at the end (line 181).\n\nResult: cancelled workflows can finish as 'completed', defeating the purpose of cancellation.\n\nFix: Check c.state.status === 'cancelled' at the top of each iteration in the plan execution loop. Break out and return {status: 'cancelled'} if detected.\n\nFiles: src/rival/core/workflow-coordinator.ts\nFound by: Codex review\nSeverity: High","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:08.12199-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:08.12199-06:00","labels":["bug","high-priority"]}
{"id":"rival-19f","title":"Rename plan field actorType -\u003e actorName (no deprecation)","description":"Context:\nProject is greenfield/unreleased. Current plan node field  is confusing and reads like a TypeScript type rather than a runtime actor registry key.\n\nDecision:\nRename  to  everywhere with no backward-compat/deprecation layer.\n\nScope:\n1) Types/schema\n- Update StepPlanNode in src/rival/types/plan.ts from  to .\n- Update Zod schema validation keys and related plan docs/comments.\n\n2) Compiler\n- In src/rival/builder/compiler.ts, emit  in plan nodes.\n- Keep generated actor registry key format unchanged unless separately scoped.\n\n3) Runtime\n- In src/rival/core/workflow-coordinator.ts, resolve step actor via .\n- Update all error messages/log text to reference actor name consistently.\n\n4) Tests\n- Update all tests constructing plan nodes manually (phase1 and any others) to use .\n- Update assertions/messages that mention actorType.\n\n5) Public API/docs/comments\n- Update src/rival/index.ts examples and any inline docs to use .\n- Ensure no remaining  references in src/test docs.\n\nAcceptance criteria:\n- Zero occurrences of  in src/test (except potential historical changelog notes).\n- Build/typecheck passes.\n- Existing tests pass with renamed field.\n- Public examples use .","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-08T22:26:52.306011-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:52:35.070159-06:00","closed_at":"2026-02-08T22:52:35.070159-06:00","close_reason":"Closed"}
{"id":"rival-1mf","title":"Roadmap: Missing workflow language and platform features","description":"Backlog umbrella derived from MISSING_FEATURES.md. Tracks missing workflow-language and platform capabilities, prioritized as: (1) core runtime gaps, (2) DX/major capabilities, (3) enterprise/scale. Use this as the parent roadmap item and attach implementation beads as dependencies.","status":"open","priority":1,"issue_type":"feature","created_at":"2026-02-12T11:13:11.587823-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:13:11.587823-06:00","dependencies":[{"issue_id":"rival-1mf","depends_on_id":"rival-tuo","type":"blocks","created_at":"2026-02-12T11:17:27.522415-06:00","created_by":"behrooz"},{"issue_id":"rival-1mf","depends_on_id":"rival-76p","type":"blocks","created_at":"2026-02-12T11:19:36.872394-06:00","created_by":"behrooz"},{"issue_id":"rival-1mf","depends_on_id":"rival-uic","type":"blocks","created_at":"2026-02-12T11:20:07.635625-06:00","created_by":"behrooz"}]}
{"id":"rival-3u4","title":"Loop coordinator actors for nested forEach orchestration","description":"Introduce loop-scoped coordinator actors so each forEach is orchestrated by a dedicated actor (including nested loops). Parent workflow coordinator delegates loop execution to loop coordinators instead of directly running nested loop internals in one actor action.\\n\\nGoals:\\n- Remove nested-loop blocking path in workflow coordinator.\\n- Make cancel/responsiveness consistent across top-level and nested loops.\\n- Keep deterministic result shape and existing failure semantics.\\n\\nScope:\\n1) Add LoopCoordinator actor/factory responsible for:\\n   - iterator kickoff and item collection\\n   - sequential and parallel iteration progression\\n   - nested loop delegation by spawning child loop coordinators\\n   - per-loop hard-failure/continue-on-error behavior\\n   - final loop result aggregation (iterations array)\\n2) Workflow coordinator integration:\\n   - replace direct nested executeLoopNode blocking path with loop-coordinator delegation\\n   - callback/message-based completion from loop coordinator to parent coordinator\\n3) Correlation/identity model:\\n   - deterministic actor keys per workflowId + loop path + iteration context\\n   - stale-callback/token guards preserved\\n4) Cancellation semantics:\\n   - parent cancel propagates to active loop coordinator chain (best effort)\\n   - no long-running blocking loop path in coordinator actions\\n5) Tests:\\n   - nested seq-in-seq, seq-in-par, par-in-seq, par-in-par\\n   - cancel during deep nested loop progression\\n   - hard-failure and continue-on-error across nested boundaries\\n   - result ordering/determinism\\n\\nAcceptance criteria:\\n- No nested loop execution path in workflow coordinator that blocks on waitForStepTerminal for loop orchestration.\\n- Nested loop progression is actor-to-actor callback/message driven.\\n- Existing forEach result contract remains compatible.\\n- Engine + foreach + step-actor test suites pass with new nested behavior coverage.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-12T10:11:17.695829-06:00","created_by":"behrooz","updated_at":"2026-02-12T10:11:17.695829-06:00","labels":["actors","architecture","loops"]}
{"id":"rival-43z","title":"Introduce explicit coordinator state machine","description":"Problem:\nCoordinator orchestration is currently an implicit state machine spread across action code paths. It works, but transition logic is not explicit, making behavior harder to reason about, review, and extend.\n\nGoal:\nIntroduce an explicit, official state machine model for workflow coordination.\n\nDesired outcome:\n- States and legal transitions are declared centrally (single source of truth).\n- Actions perform validated transitions through that state machine.\n- Transition side effects (scheduling, completion reporting, timestamps, error fields) are deterministic and testable.\n\nScope:\n1) State model\n- Define explicit state enum and transition map/table.\n- Include at minimum: pending, running, completed, failed, cancelled.\n- Include transition events (e.g., START, STEP_SUCCESS, STEP_FAILURE, CANCEL, FINISH, INTERNAL_ERROR).\n\n2) Transition engine\n- Add transition helper(s) that validate legal transitions and apply state mutations atomically.\n- Reject/ignore invalid transitions with clear diagnostics.\n\n3) Coordinator integration\n- Refactor start/processNextStep/cancel to use transition helper instead of ad hoc mutation.\n- Ensure scheduling and completion callbacks are tied to explicit transition outcomes.\n\n4) Observability\n- Add optional transition log entries (fromState -\u003e event -\u003e toState) for debugging.\n\n5) Tests\n- Transition matrix tests (legal and illegal transitions).\n- End-to-end workflow tests covering success/failure/cancel.\n- Regression tests for double-finalization and duplicate tick handling.\n\n6) Docs\n- Add concise state diagram/transition table to docs/comments.\n- Explain how to add new states/events safely.\n\nAcceptance criteria:\n- Coordinator state changes only via explicit transition path.\n- Illegal transitions are blocked and tested.\n- Existing workflow behavior preserved (except intended clarifications).\n- State model is documented and easy for contributors to follow.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-08T22:38:20.854931-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:38:20.854931-06:00"}
{"id":"rival-4pz","title":"Hide compile step from public workflow DX","description":"Problem:\nCurrent public API requires users to call createWorkflow(...).build() and then compileWorkflow(...). This is perceived as leaky internals and poor DX.\n\nGoal:\nMake workflow authoring a single high-level flow where compilation is implicit/hidden from normal users.\n\nDesired outcome:\n- Typical usage does not require importing or calling compileWorkflow.\n- Builder path returns a runnable/registrable artifact directly (or via explicit high-level terminal method that is not named compile).\n- Existing low-level compile primitives can remain internal/advanced, but should not be the default documented API.\n\nScope:\n1) API redesign:\n   - Introduce a primary fluent terminal path that hides compilation.\n   - Decide compatibility strategy for existing .build() behavior (deprecate or alias strategy).\n2) Runtime wiring:\n   - Ensure resulting object can be directly registered with setup/use and registry helpers.\n3) Docs/examples:\n   - Update all public examples to new primary path.\n   - Move compileWorkflow to advanced section only (or internal).\n4) Tests:\n   - Add tests proving zero explicit compile call in standard usage.\n   - Keep backward-compat tests if old API remains temporarily.\n\nAcceptance criteria:\n- A new user can define and run a workflow without ever seeing compileWorkflow.\n- Existing examples in src/rival/index.ts comments and tests reflect hidden-compile DX.\n- Migration notes provided for previous API if behavior changed.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-08T22:17:36.786251-06:00","created_by":"behrooz","updated_at":"2026-02-08T23:15:49.112574-06:00"}
{"id":"rival-5tw","title":"Enforce unique step names at builder/compile time","description":"Duplicate step names silently corrupt execution. Actor names are generated as {workflow}_{stepName} in compiler.ts:41 - duplicates overwrite actor entries. At runtime, workflow-coordinator.ts:142 reuses the same key for step instances.\n\nResult: step collisions, wrong actor/function execution, state bleed across nodes.\n\nFix: Add validation in WorkflowBuilder.step() and/or compileWorkflow() to reject duplicate step names with a clear error message.\n\nFiles: src/rival/builder/workflow-builder.ts, src/rival/builder/compiler.ts\nFound by: Codex review\nSeverity: High","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:02.36434-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:49:25.684771-06:00","closed_at":"2026-02-08T20:16:07.370147-06:00","close_reason":"Closed","labels":["bug","high-priority"]}
{"id":"rival-76p","title":"Parallel step groups with join strategies","description":"Add first-class fluent parallel branch groups for independent concurrent branches in the workflow DSL.\n\nTarget DSL ergonomics:\n- .parallel(name?)\n    .branch(\"db\", (p) =\u003e p.step(createDatabaseUser))\n    .branch(\"crm\", (p) =\u003e p.workflow(createCRMProfileWorkflow))\n    .branch(\"email\", (p) =\u003e p.step(sendWelcomeEmail))\n    .join(\"all\")\n    .finally((ctx) =\u003e ({ branchCount: 3 }))\n- Single-call convenience may exist: .parallel([ ... ], { join: \"all\" }), but fluent chain is canonical.\n\nExecution model requirements (Rivet/actor strict):\n- No blocking polling loops inside actor actions.\n- Parent coordinator delegates parallel block orchestration to a dedicated coordinator actor (similar to loop coordinator pattern).\n- Branch completion enters parent via callback action with correlation token.\n- Cancellation propagates parent -\u003e parallel coordinator -\u003e all active branches (best effort).\n\nSemantics (Phase 1):\n- join=\"all\" only (wait_all) for initial implementation.\n- Deterministic output shape keyed by branch name in definition order.\n- Hard failure in any branch fails block unless branch/step config explicitly continueOnError.\n- Parallel block result is written to stepResults under block name.\n\nFollow-ups (separate phases):\n- join=\"first\" and join=\"n\" strategies.\n- per-branch timeout/join thresholds.\n\nAcceptance criteria:\n1) Fluent builder API supports parallel().branch().join().finally() with strong typing.\n2) Compiler lowers to plan nodes with deterministic ordering and names.\n3) Runtime uses callback-driven actor orchestration and token guards.\n4) Tests: success, hard-failure, continueOnError, cancel during active fan-out, nested under loop/branch.","notes":"Implemented Phase-1 parallel primitive with actor-driven execution: added builder.parallel(name,{branches,join:'all'}), compiler lowering to ParallelPlanNode + parallel coordinator actor registration, new core/parallel-coordinator actor (callback/token guarded), workflow coordinator onParallelFinished path, and loop coordinator nested-parallel support. Added test/parallel-block.test.ts covering builder/compiler, success, failure, and parallel-inside-loop. Typecheck passes; targeted tests pass functionally, though bun test process may keep handles open (timeout wrapper returns 124 after printed success summary). Fluent chain API (parallel().branch().join().finally()) remains follow-up syntax layer.\nPlan reset (2026-02-13): canonical parallel design\n- Scope: workflow control-flow concurrency only (fan-out/fan-in inside one run). Not engine run-queue concurrency and not replacing forEach data-parallel loops.\n- Canonical API direction: `.concurrent(name?, tasks, { continueOn })` where each task uses `{ id?, name?, do }`. Avoid `branch/path` terminology to keep conditional branching namespace clean.\n- Continue policy phases: Phase 1 `continueOn: \"all\"` only. Follow-ups: `\"first\"`, `\"last\"`, and `null` (detached). Predicate-function continuation deferred; prefer declarative selectors later if needed.\n- Task payload: `do` supports either a step function or an entire workflow definition/subworkflow.\n- Runtime architecture (Rivet strict): parent workflow coordinator delegates to dedicated ParallelCoordinator actor; callback-driven progression via `onParallelFinished`; no blocking polling loops in actor actions; token/callback-name guards for stale-message rejection.\n- Cancel semantics: best-effort propagation parent -\u003e parallel coordinator -\u003e all active children (step/loop/parallel coordinators) with warning logs on propagation failures.\n- Result contract: one stepResults entry for the concurrent node, containing deterministic per-task outcomes keyed by task identity in declaration order.\n- Reuse guidance: reuse loop-coordinator orchestration skeleton (token guards, callback ingress, cancel fan-out), but not loop item-index state machine internals.\n- Testing matrix: success/all, hard-failure, continueOnError interactions, cancel during fan-out, nested combinations (concurrent in loop / loop in concurrent / concurrent in concurrent), deterministic output ordering, stale callback token guard behavior.\n- Cross-bead alignment: adopt `do` terminology consistently across builder inputs; coordinate with `rival-rms` identity model work (allow repeated step functions and internal unique IDs).","status":"in_progress","priority":2,"issue_type":"feature","created_at":"2026-02-12T11:13:53.191744-06:00","created_by":"behrooz","updated_at":"2026-02-12T22:14:14.313144-06:00"}
{"id":"rival-90s","title":"Replace console.log with pino logger in workflow-coordinator","description":"The coordinator uses raw console.log for all logging (9 call sites in src/rival/core/workflow-coordinator.ts). Should use pino like the step actors do via createStepLogger. Need to wire up a coordinator-level logger variant and replace all console.log calls.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T18:44:30.984414-06:00","created_by":"behrooz","updated_at":"2026-02-08T18:44:30.984414-06:00","labels":["enhancement"]}
{"id":"rival-988","title":"Reset stale error metadata on workflow rerun","description":"run() in workflow-coordinator.ts resets some fields (status, input, stepResults, currentStepIndex) but not error, failedStep, or completedAt before starting execution (line 90 onward).\n\nResult: getState() may expose stale failure details from a previous run after a successful rerun.\n\nFix: Reset error=null, failedStep=null, completedAt=null at the start of run().\n\nFiles: src/rival/core/workflow-coordinator.ts\nFound by: Codex review\nSeverity: Medium","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:20.306328-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:20.306328-06:00","labels":["bug"]}
{"id":"rival-a7h","title":"Local/function-only execution mode","description":"Add an opt-in mode where workflows execute as plain function calls without the Rivet actor model. Same builder API, same StepContext, retries, timeouts, logging, and result threading — but steps are called directly as functions instead of going through actor getOrCreate/execute. Removes RivetKit dependency for simple single-process pipelines.\n\nKey design points:\n1. Retry/timeout logic moves from step-actor into a lightweight runner/executor\n2. Same WorkflowDefinition from builder compiles to a different backend\n3. forEach parallel uses Promise.all directly\n4. Could be a flag on rival() like { mode: \"local\" } or a separate entry point like rivalLocal()\n\nTradeoff: no actor state persistence, no distributed coordination, no external inspect/resume — but much simpler for straight-through pipelines.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-11T20:31:28.002548-06:00","created_by":"behrooz","updated_at":"2026-02-11T20:31:28.002548-06:00","labels":["feature"]}
{"id":"rival-aox","title":"Implement timeout, onTimeout, and onError in StepConfig","description":"StepConfig defines timeout, onTimeout, and onError (src/rival/types/step.ts:18-31) but createStepActor only uses maxAttempts and backoff (step-actor.ts:78). WorkflowDefinition.onError (workflow.ts:21) is also never used by compiler or coordinator.\n\nThe API promises behavior the runtime does not implement. Either implement these features or remove/deprecate them from the types until they are.\n\nFiles: src/rival/core/step-actor.ts, src/rival/core/workflow-coordinator.ts, src/rival/builder/compiler.ts, src/rival/types/step.ts\nFound by: Codex review\nSeverity: High","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:14.475224-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:14.475224-06:00","labels":["enhancement","high-priority"]}
{"id":"rival-asl","title":"Workflow and schema versioning/migration model","description":"Add workflow version identity, compatibility metadata, and migration hooks for input/output schema evolution. Define deployment-time and run-time version selection behavior.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-12T11:15:26.120351-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:15:26.120351-06:00"}
{"id":"rival-b2e","title":"Workflow start triggers (event, schedule, webhook)","description":"Add trigger registration layer for event-driven and schedule-driven workflow starts. Initial scope: event name, cron schedule, and inbound webhook trigger adapters.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-12T11:14:44.824248-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:14:44.824248-06:00"}
{"id":"rival-cck","title":"Execution audit trail and history replay primitives","description":"Add append-only workflow execution history and retrieval API for debugging/compliance. Define replay/simulation scope and event schema versioning constraints.","status":"open","priority":3,"issue_type":"task","created_at":"2026-02-12T11:15:05.466077-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:15:05.466077-06:00"}
{"id":"rival-drm","title":"[EPIC] Rivet Anti-Pattern Remediation","description":"Comprehensive remediation of 10 Rivet anti-patterns identified during expert review. Overall compliance rated Moderate - strong on actor-per-entity and coordinator/data separation, but needs attention on type safety, state design, action API, lifecycle hooks, and error handling. Each sub-issue addresses one finding.","notes":"## Recommended Execution Order\n\n**Phase 1 — Foundations (P1, do first):**\n1. rival-drm.1: Type safety (c.client() casting) — unblocks everything\n2. rival-drm.2: Replace callback protocol (depends on .1)\n3. rival-drm.4: Bundle positional params (related to .2)\n4. rival-drm.3: Decompose god state — unblocks lifecycle work\n\n**Phase 2 — Lifecycle \u0026 Errors (P2):**\n5. rival-drm.6: Adopt lifecycle hooks (depends on .3)\n6. rival-drm.9: Move context to vars (depends on .6)\n7. rival-drm.5: Unify execution tokens\n8. rival-drm.7: Adopt UserError\n9. rival-drm.8: Parallelize cancel propagation (quick win)\n\n**Phase 3 — Cleanup (P3):**\n10. rival-drm.10: Fix test closure mutation\n\n## Dependency Chain\nrival-drm.1 → rival-drm.2 (↔ rival-drm.4)\nrival-drm.3 → rival-drm.6 → rival-drm.9\nOthers are independent.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-13T21:54:51.938113-06:00","created_by":"behrooz","updated_at":"2026-02-13T22:00:09.74221-06:00","labels":["architecture","rivet-compliance"]}
{"id":"rival-drm.1","title":"Fix unsafe c.client() casting — restore Rivet type safety","description":"**Severity: High**\n\nEvery coordinator casts c.client() to Record\u003cstring, unknown\u003e and further casts to custom handle types, completely bypassing Rivet's built-in type safety.\n\n**Locations:**\n- for-loop-coordinator.ts:235\n- parallel-coordinator.ts:244\n- workflow-coordinator.ts:314\n- step-actor.ts:117\n\n**Current:** `const client = c.client() as Record\u003cstring, unknown\u003e`\n**Expected:** c.client() should return a fully type-safe client when the registry is properly typed via setup().\n\n**Recommendation:** Type the registry generically and thread the registry type through all coordinator factories. The actor-handles.ts abstraction layer would become unnecessary.\n\n**Impact:** No compile-time verification that actor refs exist or that action signatures match. Runtime casts hide mismatches.","status":"open","priority":1,"issue_type":"bug","created_at":"2026-02-13T21:55:09.866908-06:00","created_by":"behrooz","updated_at":"2026-02-13T21:55:09.866908-06:00","labels":["rivet-compliance","type-safety"],"dependencies":[{"issue_id":"rival-drm.1","depends_on_id":"rival-drm","type":"parent-child","created_at":"2026-02-13T21:55:09.868419-06:00","created_by":"behrooz"}]}
{"id":"rival-drm.10","title":"Fix test closure mutation across actor boundaries","description":"**Severity: Low (test-only, but indicates incorrect mental model)**\n\nconcurrent-block.test.ts:269 uses a mutable closure variable `let finished = 0` that is mutated from inside an actor step function. This only works because the filesystem driver runs actors in-process.\n\nIn a real Rivet deployment (Rivet Cloud, distributed runners), actors run in isolated processes. The closure variable would not be shared.\n\n**Current:**\n```typescript\nlet finished = 0;\nrun: async () =\u003e {\n  finished += 1;  // Mutating closure from actor context\n  return 'done';\n}\n// Later: expect(finished).toBe(0)  // Only true in-process\n```\n\n**Recommendation:** Assert on actor state/results, not external closure mutations. This ensures tests remain valid if the runtime model changes.","status":"open","priority":3,"issue_type":"bug","created_at":"2026-02-13T21:56:01.055616-06:00","created_by":"behrooz","updated_at":"2026-02-13T21:56:01.055616-06:00","labels":["rivet-compliance","testing"],"dependencies":[{"issue_id":"rival-drm.10","depends_on_id":"rival-drm","type":"parent-child","created_at":"2026-02-13T21:56:01.05652-06:00","created_by":"behrooz"}]}
{"id":"rival-drm.2","title":"Replace manual callback protocol with Rivet native inter-actor communication","description":"**Severity: High**\n\nEvery actor implements a notifyParent/notifyCoordinator function that manually looks up parent actors via string-based dynamic lookup and calls callback methods by convention name. This reimplements message passing on top of Rivet's already-typed action system.\n\n**Locations:**\n- step-actor.ts:108-134 (notifyCoordinator)\n- for-loop-coordinator.ts:72-103 (notifyParent)\n- parallel-coordinator.ts:74-99 (notifyParent)\n- workflow-coordinator.ts:86-108 (notifyParent)\n\n**Current pattern:**\n```typescript\nconst parentType = c.client()[parentRef] as | { getOrCreate: ... } | undefined;\nconst callback = parentType?.getOrCreate(parentKey).onLoopFinished;\n```\n\n**Expected:** Rivet's typed client for direct action calls: c.client().actorType.getOrCreate(key).action()\n\n**Recommendation:** Each child actor should know its parent's actor type at compile time, not discover it via string-based dynamic lookup. Closely related to Finding 1 (type safety).","status":"open","priority":1,"issue_type":"bug","created_at":"2026-02-13T21:55:14.579866-06:00","created_by":"behrooz","updated_at":"2026-02-13T21:55:14.579866-06:00","labels":["architecture","rivet-compliance"],"dependencies":[{"issue_id":"rival-drm.2","depends_on_id":"rival-drm","type":"parent-child","created_at":"2026-02-13T21:55:14.580991-06:00","created_by":"behrooz"},{"issue_id":"rival-drm.2","depends_on_id":"rival-drm.1","type":"blocks","created_at":"2026-02-13T21:59:59.310557-06:00","created_by":"behrooz"},{"issue_id":"rival-drm.2","depends_on_id":"rival-drm.4","type":"relates-to","created_at":"2026-02-13T21:59:59.643923-06:00","created_by":"behrooz"}]}
{"id":"rival-drm.3","title":"Decompose God State — split persisted state vs ephemeral vars","description":"**Severity: Medium-High**\n\nCoordinator state interfaces are massive flat objects (24-30+ fields) mixing orchestration metadata, runtime tracking, business results, and lifecycle timestamps. All fields are persisted to disk.\n\n**Locations:**\n- LoopCoordinatorState: ~30 fields (for-loop-coordinator.ts:16-47)\n- ParallelCoordinatorState: ~24 fields (parallel-coordinator.ts:29-55)\n- WorkflowCoordinatorState: ~23 fields (workflow-coordinator.ts:26-53)\n\n**Runtime-only data that should use `vars` instead of `state`:**\n- activeStepActors, activeChildLoops, activeChildParallels maps\n- inFlight tracking maps\n- Execution tokens and parent references\n\n**Recommendation:**\n- Move runtime-only tracking to `vars` via `createVars`\n- Group related fields into sub-objects\n- Keep only essential business data (results, status, timestamps) in persisted state","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-13T21:55:14.715579-06:00","created_by":"behrooz","updated_at":"2026-02-13T21:55:14.715579-06:00","labels":["architecture","rivet-compliance","state-design"],"dependencies":[{"issue_id":"rival-drm.3","depends_on_id":"rival-drm","type":"parent-child","created_at":"2026-02-13T21:55:14.716526-06:00","created_by":"behrooz"}]}
{"id":"rival-drm.4","title":"Bundle positional action parameters into typed option objects","description":"**Severity: Medium-High**\n\nSeveral actions have 8-11 positional parameters, making them fragile and error-prone. Swapping two string arguments produces a silent runtime bug.\n\n**Locations:**\n- runLoop: 11 params (for-loop-coordinator.ts:190-202)\n- runParallel: 10 params (parallel-coordinator.ts:186-197)\n- run (workflow coordinator): 9 params (workflow-coordinator.ts:208-218)\n- execute (step actor): 8 params (step-actor.ts:222-231)\n\n**Example:**\n```typescript\n// Current: fragile positional params\nrunLoop(selfKey, workflowId, input, parentStepResults, parentLoopContext,\n  loopKeyPrefix, parentRef, parentKey, parentCallbackName, parentToken)\n\n// Recommended: single typed object\nrunLoop(c, opts: RunLoopOptions)\n```\n\n**Recommendation:** Bundle parameters into typed option objects for all inter-actor actions. Rivet examples show actions taking 1-2 structured parameters.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-13T21:55:29.952649-06:00","created_by":"behrooz","updated_at":"2026-02-13T21:55:29.952649-06:00","labels":["api-design","rivet-compliance"],"dependencies":[{"issue_id":"rival-drm.4","depends_on_id":"rival-drm","type":"parent-child","created_at":"2026-02-13T21:55:29.953613-06:00","created_by":"behrooz"},{"issue_id":"rival-drm.4","depends_on_id":"rival-drm.2","type":"relates-to","created_at":"2026-02-13T21:59:59.63291-06:00","created_by":"behrooz"}]}
{"id":"rival-drm.5","title":"Unify execution token strategy and evaluate actor-per-execution model","description":"**Severity: Medium**\n\nTwo different token generation strategies exist:\n- Step actors: `Date.now() + Math.floor(Math.random() * 1000000)` (collision-prone) — step-actor.ts:232\n- Coordinators: monotonic increment via `nextExecutionToken()` — orchestration/tokens.ts\n\nThe need for execution tokens at all suggests actors are being reused across workflow runs rather than creating a fresh actor per execution, which may conflict with Rivet's actor-per-entity pattern.\n\n**Recommendation:**\n1. Unify on `nextExecutionToken` for all actors\n2. Evaluate whether actor keys should be unique per execution attempt, potentially eliminating the need for tokens entirely","status":"open","priority":2,"issue_type":"bug","created_at":"2026-02-13T21:55:35.451229-06:00","created_by":"behrooz","updated_at":"2026-02-13T21:55:35.451229-06:00","labels":["architecture","rivet-compliance"],"dependencies":[{"issue_id":"rival-drm.5","depends_on_id":"rival-drm","type":"parent-child","created_at":"2026-02-13T21:55:35.45247-06:00","created_by":"behrooz"}]}
{"id":"rival-drm.6","title":"Adopt Rivet lifecycle hooks (createVars, onCreate, onDestroy)","description":"**Severity: Medium**\n\nNone of the actors use any Rivet lifecycle hooks. All initialization is brute-force state overwrite in action handlers.\n\n**Missing hooks:**\n- `createVars` — everything is in persisted state, even ephemeral runtime data\n- `onCreate` — initial state set via verbose type assertions (`null as string | null`)\n- `onDestroy` — no cleanup when actors are destroyed (leaked refs in parent tracking maps)\n- `onStateChange` — missed opportunity for audit logging or external sync\n\n**Locations:** All actor definitions:\n- step-actor.ts\n- workflow-coordinator.ts\n- for-loop-coordinator.ts\n- parallel-coordinator.ts\n\n**Recommendation:** Use createVars for runtime-only maps, onCreate for one-time initialization, onDestroy for cleanup. Closely related to Finding 3 (God State).","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-13T21:55:40.484839-06:00","created_by":"behrooz","updated_at":"2026-02-13T21:55:40.484839-06:00","labels":["lifecycle","rivet-compliance"],"dependencies":[{"issue_id":"rival-drm.6","depends_on_id":"rival-drm","type":"parent-child","created_at":"2026-02-13T21:55:40.485758-06:00","created_by":"behrooz"},{"issue_id":"rival-drm.6","depends_on_id":"rival-drm.3","type":"blocks","created_at":"2026-02-13T21:59:59.410362-06:00","created_by":"behrooz"}]}
{"id":"rival-drm.7","title":"Adopt Rivet UserError for client-facing errors","description":"**Severity: Medium**\n\nThe codebase exclusively uses plain Error and console.warn/console.error. Rivet provides UserError with structured codes and metadata for client-facing errors.\n\n**Examples of errors that should be UserError:**\n- `throw new Error('Workflow already running')` — workflow-coordinator.ts:221\n- Input validation failures — workflow-coordinator.ts:228\n- Actor ref not found — workflow-coordinator.ts:323\n- Step execution failures surfaced to clients\n\n**Recommendation:** Use UserError with machine-readable codes (e.g. 'workflow_already_running', 'input_validation_failed', 'actor_not_found') for operational errors. Reserve plain Error for truly internal failures that get masked as 'internal_error' per Rivet's security model.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-13T21:55:40.868396-06:00","created_by":"behrooz","updated_at":"2026-02-13T21:55:40.868396-06:00","labels":["error-handling","rivet-compliance"],"dependencies":[{"issue_id":"rival-drm.7","depends_on_id":"rival-drm","type":"parent-child","created_at":"2026-02-13T21:55:40.869522-06:00","created_by":"behrooz"}]}
{"id":"rival-drm.8","title":"Parallelize cancel propagation with Promise.allSettled","description":"**Severity: Low-Medium**\n\nCancel handlers propagate cancellation to children sequentially (await one after another). These are independent operations targeting different actor types.\n\n**Locations:**\n- workflow-coordinator.ts:652-686\n- for-loop-coordinator.ts:696-719\n- parallel-coordinator.ts:589-632\n\n**Current:**\n```typescript\nawait propagateStepCancel(...);\nawait propagateLoopCancel(...);\nawait propagateParallelCancel(...);\n```\n\n**Recommended:**\n```typescript\nawait Promise.allSettled([\n  propagateStepCancel(...),\n  propagateLoopCancel(...),\n  propagateParallelCancel(...),\n]);\n```\n\nA slow or failing cancel to one child type delays cancellation of all others.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-13T21:55:54.84353-06:00","created_by":"behrooz","updated_at":"2026-02-13T21:55:54.84353-06:00","labels":["perf","rivet-compliance"],"dependencies":[{"issue_id":"rival-drm.8","depends_on_id":"rival-drm","type":"parent-child","created_at":"2026-02-13T21:55:54.844693-06:00","created_by":"behrooz"}]}
{"id":"rival-drm.9","title":"Move ExecuteContext from persisted state to ephemeral vars","description":"**Severity: Medium**\n\nstep-actor.ts:208 stores the full ExecuteContext (workflow input + all previous step results + loop context) in persisted state. This means:\n- Full context serialized and written to disk on every state change\n- After actor wake, stale context data persists even if workflow moved on\n- For large workflows with many steps, creates significant storage bloat\n\nThe context is only needed during the active execution between `execute` and finalization.\n\n**Location:** step-actor.ts:208 — `context: null as ExecuteContext | null` in state\n\n**Recommendation:** Move `context` and `config` to vars (ephemeral). Pass into _attempt schedule call or keep in createVars. Related to Finding 3 (God State) and Finding 6 (lifecycle hooks).","status":"open","priority":2,"issue_type":"bug","created_at":"2026-02-13T21:56:00.927661-06:00","created_by":"behrooz","updated_at":"2026-02-13T21:56:00.927661-06:00","labels":["rivet-compliance","state-design"],"dependencies":[{"issue_id":"rival-drm.9","depends_on_id":"rival-drm","type":"parent-child","created_at":"2026-02-13T21:56:00.928563-06:00","created_by":"behrooz"},{"issue_id":"rival-drm.9","depends_on_id":"rival-drm.6","type":"blocks","created_at":"2026-02-13T21:59:59.506743-06:00","created_by":"behrooz"}]}
{"id":"rival-e3k","title":"Workflow metrics and analytics surface","description":"Add runtime metrics collection and query surface for success rate, duration, and failure classes. Include minimal aggregation model and test coverage.","status":"open","priority":3,"issue_type":"task","created_at":"2026-02-12T11:14:55.150091-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:14:55.150091-06:00"}
{"id":"rival-fpk","title":"Expose full runtime/workflow configuration + raw actor ergonomics","description":"Context: Rival currently exposes StepConfig in types/builder, but coordinator execution still uses a hardcoded step timeout and does not consistently honor per-step timeout/onTimeout precedence. Also actor-level Rivet options (e.g., actionTimeout and related options) are not passed through factory APIs.\n\nGoal:\nMake configuration as fully exposed as possible while keeping sane defaults, and ensure advanced users can use raw actors without fighting abstractions.\n\nScope:\n1) Wire timeout precedence in coordinator execution:\n   - step config timeout \u003e workflow default step timeout \u003e coordinator fallback.\n   - implement onTimeout behavior (stop/retry; optionally continue if added).\n2) Expose factory-level options passthrough:\n   - createStepActor(..., options?)\n   - createWorkflowCoordinator(..., options?)\n   - createRegistryActor(..., options?)\n   where options can include Rivet actor options and Rival-specific defaults.\n3) Keep raw-actor usage first-class:\n   - document direct setup({ use: ... }) with compiled actors/factories.\n   - ensure no internal assumptions block direct actor registration.\n4) Tests:\n   - per-step timeout honored.\n   - precedence order behavior.\n   - onTimeout stop/retry behavior.\n   - factory option passthrough compiles and works.\n5) Docs/examples:\n   - show simple mode and advanced/raw actor mode.\n\nOut of scope:\n- New orchestration DSL features (branch/loop/parallel semantics redesign).\n\nAcceptance criteria:\n- No hardcoded-only timeout path for step execution.\n- Public API exposes configuration knobs for advanced users.\n- Existing simple usage remains ergonomic and backward compatible where practical.","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-08T21:59:57.999553-06:00","created_by":"behrooz","updated_at":"2026-02-08T21:59:57.999553-06:00"}
{"id":"rival-hrd","title":"[EPIC] Actor-native retry/timeout migration with phased rollout","description":"Epic for migrating actor-mode execution to scheduled retries/timeouts with phased, agent-delegable deliverables.\n\nPlan doc: docs/plans/rival-hrd.md\n\n## Phase Breakdown\n1. Phase 1: Step actor scheduled retry/timeout core\n2. Phase 2: Coordinator async progression (top-level only; loops remain sync)\n3. Phase 3: Engine API transition to run + wait\n4. Phase 4: Full async loop continuation state machine (deferred)\n5. Phase 5: Event-driven wait optimization (deferred)\n\n## Scope\n- Actor runtime correctness and responsiveness between retries\n- Timeout enforcement in scheduled action model\n- Clear phased boundaries to allow parallel delegation and review\n\n## Out of Scope (for early phases)\n- Full async loop continuation in phase 1-3\n- Replacing polling wait with events before baseline stability\n","status":"in_progress","priority":2,"issue_type":"epic","created_at":"2026-02-11T20:42:31.624786-06:00","created_by":"behrooz","updated_at":"2026-02-11T22:26:43.931887-06:00","labels":["bug"]}
{"id":"rival-hrd.1","title":"[Phase 1] Step actor scheduled retry/timeout core","description":"Implement scheduled retry/timeout in step actor with persisted callback address and token-guarded internal actions. Greenfield: allow breaking API changes that support async-first execution model.","acceptance_criteria":"No sleep() retry loop remains; retries use c.schedule.after. Add waiting_retry status, timeout scheduling, maxAttempts cap, coordinatorRef/coordinatorKey persistence, and step-level onError on terminal failure. Add schedule-focused tests using Vitest fake timers.","notes":"Implemented async-first step actor kickoff with scheduled _attempt/_onTimeout actions, persisted execution metadata (including coordinatorRef/coordinatorKey), waiting_retry status, retry max cap, explicit saveState before scheduling retries, and terminal step-level onError. Added schedule-focused tests in test/step-actor-scheduling.test.ts (passing). Coordinator temporarily polls step terminal state via getTerminalResult until Phase 2 callback-driven progression lands.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-11T22:27:08.230641-06:00","created_by":"behrooz","updated_at":"2026-02-11T23:21:32.862224-06:00","closed_at":"2026-02-11T23:21:32.862224-06:00","close_reason":"Closed","labels":["actor","bug","retry"],"dependencies":[{"issue_id":"rival-hrd.1","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T22:27:08.231873-06:00","created_by":"behrooz"}],"comments":[{"id":1,"issue_id":"rival-hrd.1","author":"behrooz","text":"Phase 1 completion notes\n\n- Step actor migrated to scheduled retry/timeout core with `_attempt`/`_onTimeout`, token guards, persisted coordinator address, and explicit immediate state flush before scheduling retries.\n- Step-level `onError` wired on terminal failure paths.\n- Added schedule-focused test coverage in `test/step-actor-scheduling.test.ts` (passing).\n- Coordinator currently uses temporary terminal polling bridge (`getTerminalResult`) pending Phase 2 callback-driven progression.\n\nTimer testing note\n- This repository uses `bun test` and Bun 1.3.9 in this environment does not expose `jest.useFakeTimers`/`vi.useFakeTimers` APIs.\n- Tests are still schedule-focused and deterministic enough for current Phase 1 behavior via memory driver + bounded polling.\n- If strict fake-timer semantics are required, add a dedicated follow-up task to introduce Vitest (or equivalent timer-mocking stack).\n","created_at":"2026-02-12T05:15:01Z"},{"id":3,"issue_id":"rival-hrd.1","author":"behrooz","text":"Phase 1 validation update\n\n- Confirmed Bun 1.3.9 supports fake timers via imported `jest`/`vi` from `bun:test`.\n- Updated `test/step-actor-scheduling.test.ts` to use fake timers (`jest.useFakeTimers`, `jest.advanceTimersByTime`) instead of real-time sleeps.\n- Phase 1 scope considered complete; coordinator event-driven progression remains tracked in Phase 2 (`rival-hrd.2`).\n","created_at":"2026-02-12T05:21:22Z"}]}
{"id":"rival-hrd.2","title":"[Phase 2] Coordinator async progression (loops stay sync)","description":"Make top-level coordinator non-blocking with callback-driven progression. Keep forEach/loop body orchestration synchronous in this phase (Option C scope lock).","acceptance_criteria":"run() kickoff is non-blocking and progression advances via continuation actions/callbacks. Workflow cancel and failure paths remain correct. Loop behavior remains functionally equivalent and synchronous internally.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-11T22:27:18.584251-06:00","created_by":"behrooz","updated_at":"2026-02-12T00:15:25.132499-06:00","closed_at":"2026-02-12T00:15:25.132499-06:00","close_reason":"Closed","labels":["actor","coordinator"],"dependencies":[{"issue_id":"rival-hrd.2","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T22:27:18.585225-06:00","created_by":"behrooz"}],"comments":[{"id":2,"issue_id":"rival-hrd.2","author":"behrooz","text":"External review findings to drive Phase 2 implementation\n\nCritical findings\n1) Coordinator run() blocks for entire workflow duration.\n2) Coordinator uses polling loop (`sleep(25)`) for step completion.\n3) Dead callback path: step actor emits `notifyCoordinator()`, but coordinator lacks `onStepFinished` continuation action.\n\nImplications\n- Step actor side appears ready.\n- Coordinator side is the remaining gap for event-driven, non-blocking progression.\n\nPhase 2 checklist update\n- Add coordinator action `onStepFinished(...)` as callback ingress.\n- Refactor run() to kickoff-only (non-blocking), persist execution frame, and return running state quickly.\n- Remove terminal polling loop and sleep-based waiting from coordinator path.\n- Drive progression from callback/continuation actions.\n- Preserve Option C scope lock: top-level async progression, loop internals still synchronous.\n\nDefinition-of-done additions\n- No `sleep(...)`/polling loop remains in coordinator progression.\n- Callback path is live end-to-end: step actor callback -\u003e coordinator continuation -\u003e workflow completion.\n- Existing step actor scheduled retry/timeout behavior remains unchanged and passing.\n","created_at":"2026-02-12T05:16:31Z"}]}
{"id":"rival-hrd.3","title":"[Phase 3] Engine API transition to run + wait","description":"Introduce start-and-wait model in engine/instance APIs while preserving clear terminal result semantics.","acceptance_criteria":"engine.run returns start metadata {runId,status}; engine.wait and instance.wait are implemented with timeoutMs default 300000 and pollIntervalMs default 250. Docs and tests updated for new API.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-11T22:27:28.904966-06:00","created_by":"behrooz","updated_at":"2026-02-12T00:52:52.191733-06:00","closed_at":"2026-02-12T00:52:52.191733-06:00","close_reason":"Closed","labels":["api","engine"],"dependencies":[{"issue_id":"rival-hrd.3","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T22:27:28.906026-06:00","created_by":"behrooz"}]}
{"id":"rival-hrd.4","title":"[Phase 4] Full async loop continuation state machine (deferred)","description":"Design and implement full continuation state machine for sequential/parallel/nested loop execution under async coordinator model.","acceptance_criteria":"Loop continuation state machine is decision-complete and implemented with tests for sequential, parallel fan-out/fan-in, nested loops, cancellation, and failure semantics.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-02-11T22:27:39.162574-06:00","created_by":"behrooz","updated_at":"2026-02-12T00:53:02.468358-06:00","closed_at":"2026-02-12T00:53:02.468358-06:00","close_reason":"Closed","labels":["deferred","loop"],"dependencies":[{"issue_id":"rival-hrd.4","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T22:27:39.163562-06:00","created_by":"behrooz"}]}
{"id":"rival-hrd.5","title":"[Phase 5] Event-driven wait optimization (deferred)","description":"Add event/subscription-driven wait path (broadcast-based) to reduce polling overhead while retaining polling fallback.","acceptance_criteria":"wait can use broadcast/subscription path when available and falls back to polling. Include behavior docs and tests for both paths.","status":"open","priority":3,"issue_type":"chore","created_at":"2026-02-11T22:27:49.441722-06:00","created_by":"behrooz","updated_at":"2026-02-11T22:27:49.441722-06:00","labels":["deferred","perf","wait"],"dependencies":[{"issue_id":"rival-hrd.5","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T22:27:49.442851-06:00","created_by":"behrooz"}]}
{"id":"rival-hrd.6","title":"Review timeout alignment: step actor actionTimeout vs user step timeout","description":"Investigate and decide timeout model for step execution. Evaluate whether step actor actionTimeout should be set from user-provided step timeout, and how that interacts with Rivet action timeout limits, scheduler-based _onTimeout, retries, and long-running user functions. Produce implementation guidance and acceptance criteria for greenfield behavior (no backward compatibility constraints).","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-11T23:02:44.843405-06:00","created_by":"behrooz","updated_at":"2026-02-11T23:45:11.766446-06:00","closed_at":"2026-02-11T23:45:11.766446-06:00","close_reason":"Closed","dependencies":[{"issue_id":"rival-hrd.6","depends_on_id":"rival-hrd","type":"parent-child","created_at":"2026-02-11T23:02:44.844349-06:00","created_by":"behrooz"}],"comments":[{"id":4,"issue_id":"rival-hrd.6","author":"behrooz","text":"Implemented timeout alignment + per-step actor escape hatch.\n\nWhat changed\n- Added per-step actor escape hatch: `step({ ..., actor: { options: {...} } })`.\n- Kept `timeout` as the single Rival timeout input.\n- Compiler now maps `timeout` to actor hard timeout with internal buffer: `actionTimeout = timeout + 1000ms`.\n- If timeout is absent, Rival does not inject actionTimeout (Rivet default applies unless user sets actor.options.actionTimeout).\n- If both timeout and actor.options.actionTimeout are provided, timeout mapping wins.\n- Added validation for invalid timeout values and invalid actor.options.actionTimeout.\n\nTests added\n- `test/timeout-actor-options.test.ts` covering builder config storage, validation failures, and timeout precedence behavior.\n","created_at":"2026-02-12T05:45:01Z"}]}
{"id":"rival-jg6","title":"Dead/dormant code audit cleanup (runtime + API surface)","description":"Audit summary (strict static pass):\n\nHigh-confidence dead behavior (implemented surface, no runtime effect):\n1) StepConfig.onTimeout is accepted by builder/types but not used by runtime execution.\n   - src/rival/types/step.ts:26\n   - src/rival/builder/workflow-builder.ts:89\n2) StepConfig.onError is accepted by builder/types but never invoked.\n   - src/rival/types/step.ts:30\n   - src/rival/builder/workflow-builder.ts:91\n3) WorkflowDefinition.onError is captured but not consumed by coordinator/registry runtime.\n   - src/rival/types/workflow.ts:23\n   - src/rival/builder/workflow-builder.ts:106\n\nDormant feature surface (declared but intentionally skipped):\n4) Plan node types Branch/Loop/Parallel/Workflow are modeled but coordinator skips non-step nodes.\n   - src/rival/types/plan.ts:28\n   - src/rival/types/plan.ts:43\n   - src/rival/types/plan.ts:56\n   - src/rival/types/plan.ts:67\n   - src/rival/core/workflow-coordinator.ts:155\n\nLikely unused API exports in-repo (may be external-facing):\n5) createEmptyStepState export appears unused in-repo.\n   - src/rival/core/context-builder.ts:45\n   - src/rival/index.ts:47\n6) WorkflowExecutionResult appears export-only now.\n   - src/rival/core/workflow-coordinator.ts:42\n   - src/rival/index.ts:43\n7) WorkflowRunInfo appears export-only in-repo.\n   - src/rival/types/workflow.ts:62\n   - src/rival/index.ts:80\n8) StepMetrics appears export-only in-repo.\n   - src/rival/types/step.ts:72\n   - src/rival/index.ts:66\n9) workflowRegistry/registerWorkflow exported but not used by current tests/primary flow.\n   - src/rival/core/registry-actor.ts:96\n   - src/rival/core/registry-actor.ts:445\n\nEstimated impact:\n- Dead/dormant footprint in src: ~120-220 LOC (~5-10% of src).\n\nCleanup plan required in this issue:\nA) Safe remove now (non-breaking internal)\n- Remove/trim truly internal unused helpers and stale comments.\n- Keep behavior unchanged for public APIs.\n\nB) Deprecate-first (public surface)\n- For exported-but-unused types/functions, add @deprecated + migration notes first.\n- Remove in next major only if no external usage is confirmed.\n\nC) Runtime alignment (preferred)\n- Either wire onTimeout/onError/onError(workflow) into runtime semantics OR remove from public config to avoid misleading API.\n\nAcceptance criteria:\n1) No config field is accepted by builder/types without documented runtime behavior.\n2) Non-step plan node support is either implemented or clearly marked as unsupported in public API/docs (not implied as available).\n3) Public exports have deprecation policy applied where removal is planned.\n4) Docs/examples align with actual implemented behavior.\n5) Add tests that lock behavior for whichever path is chosen (wire-in vs remove/deprecate).","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T22:21:12.30011-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:21:12.30011-06:00"}
{"id":"rival-kr3","title":"Implement branch/loop/parallel execution in coordinator","description":"Plan types for BranchPlanNode, LoopPlanNode, and ParallelPlanNode are defined in types/plan.ts but the coordinator only handles type='step' nodes. There's a TODO comment at workflow-coordinator.ts:111.\n\nThis is the main feature gap for making Rival a full workflow engine. Needs:\n- BranchSupervisor: evaluate condition actor, execute then/else path\n- LoopSupervisor: execute body repeatedly until condition is false  \n- ParallelSupervisor: spawn all children concurrently, await all results\n\nFiles: src/rival/core/workflow-coordinator.ts, src/rival/types/plan.ts\nFrom: redesign.md design spec\nSeverity: Feature - Future phase","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:43.023879-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:43.023879-06:00","labels":["enhancement","feature"],"dependencies":[{"issue_id":"rival-kr3","depends_on_id":"rival-qr7","type":"blocks","created_at":"2026-02-08T12:31:01.771712-06:00","created_by":"behrooz"},{"issue_id":"rival-kr3","depends_on_id":"rival-0wx","type":"blocks","created_at":"2026-02-08T12:31:01.863692-06:00","created_by":"behrooz"},{"issue_id":"rival-kr3","depends_on_id":"rival-aox","type":"blocks","created_at":"2026-02-08T12:31:01.95467-06:00","created_by":"behrooz"}]}
{"id":"rival-lap","title":"Build Rival Engine - standalone executable with UI","description":"The two-tier vision has Rival Library (done) and Rival Engine (not started). The engine would be a standalone executable with a web UI for:\n\n- Workflow monitoring dashboard\n- Live step execution visualization\n- Log viewing (mockups exist in mockups/ui-mockup-logs.html)\n- Workflow launching and management\n- Nested workflow visualization (mockups/ui-mockup-nested.html)\n\nUI mockups already exist in mockups/ directory. Plan AST is already serializable for UI consumption. WebSocket integration was explored in earlier commits.\n\nFiles: mockups/\nFrom: redesign.md, .claude/RIVAL.md\nSeverity: Feature - Future phase","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:50.457537-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:50.457537-06:00","labels":["enhancement","feature"],"dependencies":[{"issue_id":"rival-lap","depends_on_id":"rival-kr3","type":"blocks","created_at":"2026-02-08T12:31:05.65873-06:00","created_by":"behrooz"},{"issue_id":"rival-lap","depends_on_id":"rival-u2e","type":"blocks","created_at":"2026-02-08T12:31:05.773266-06:00","created_by":"behrooz"}]}
{"id":"rival-mep","title":"Support remote/distributed Rivet runtime (horizontal execution)","description":"Rival currently runs local/in-process via setup({ use: ...actors }) + start({ disableDefaultServer: true }). This limits workflows to a single process and blocks intended Rivet horizontal distribution patterns.\\n\\nWhy this matters (P1):\\n- Production deployment should support remote actor runtime and horizontal scale.\\n- Workflows should execute across distributed Rivet actors rather than only local headless mode.\\n\\nGoal:\\n- Enable Rival engine to run against a remote/distributed Rivet runtime while preserving current local convenience mode.\\n\\nScope:\\n1) Engine modes\\n- Keep existing local mode () for DX/testing.\\n- Add remote mode (new API or options) that connects to a remote Rivet client/runtime.\\n\\n2) Registration/deployment model\\n- Decouple compile-time plan generation from local actor registration.\\n- Define how step actors/coordinator are published/registered for remote runtime.\\n\\n3) Actor refs + identity\\n- Ensure actor refs are deterministic and globally safe for distributed environments.\\n- Document namespace/encoding guarantees for remote lookup.\\n\\n4) Reliability semantics\\n- Define behavior for network failures, unavailable actor refs, retries, and timeout boundaries.\\n- Maintain workflow-level failure reporting consistency.\\n\\n5) Backward compatibility\\n- No regression for current local mode and existing API consumers.\\n\\n6) Tests/docs\\n- Integration tests for remote mode (including nested forEach and failure paths).\\n- Clear docs for local vs remote execution, deployment prerequisites, and migration notes.\\n\\nAcceptance criteria:\\n- Rival can run workflows against a remote/distributed Rivet runtime.\\n- Same workflow definition can be executed in local and remote modes.\\n- Core semantics (step/loop execution and failure behavior) stay consistent across modes.\\n- Local mode remains supported and unchanged by default.","status":"open","priority":1,"issue_type":"feature","created_at":"2026-02-11T20:06:20.21663-06:00","created_by":"behrooz","updated_at":"2026-02-11T20:06:20.21663-06:00","labels":["architecture","rivetkit","scalability"]}
{"id":"rival-o0p","title":"Function-call style step arguments + hidden compile DX","description":"Problem:\nWorkflow step authoring does not feel like normal function calls. Passing static step arguments is unintuitive (requires plan/config internals), and compile details leak into user-facing DX.\n\nGoal:\nExpose a function-call-like API where developers pass step arguments naturally, while compilation/actor internals remain hidden in the default path.\n\nTarget API shape (example):\n- defineWorkflow('lumber')\n    .step(findTree, { radius: 250, species: 'oak' })\n    .step(chopTree, { blade: 'A2' })\n    .run({ location: 'north-forest' })\n\nStep function ergonomics:\n- Support either  or  pattern (choose one and document clearly).\n- Args must be serializable.\n\nScope:\n1) Builder API\n- Add first-class step args on  in fluent API.\n- Keep simple no-args step path ergonomic.\n\n2) Runtime plumbing\n- Ensure step args flow through compile/runtime to step actor execute context predictably.\n- Do not require users to manually place arguments into plan config.\n\n3) Hidden compile defaults\n- Standard user path should never require explicit compileWorkflow call.\n- compile internals may remain for advanced usage but not default docs/examples.\n\n4) Typing\n- Preserve strong TS inference for step args and input where feasible.\n- Provide clear type errors for non-serializable args.\n\n5) Tests\n- Add tests for:\n  a) static args passed to step functions correctly\n  b) args + per-run input used together\n  c) no-args steps still work\n  d) serialization guard behavior\n\n6) Docs/examples\n- Rewrite primary examples to function-call style step args.\n- Explain mental model briefly: looks like functions, runs as actors.\n\nAcceptance criteria:\n- A new user can define workflow steps with arguments without touching plan internals.\n- Primary docs/examples show no explicit compile call.\n- Step argument passing is stable, typed, and covered by tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-08T22:35:07.120356-06:00","created_by":"behrooz","updated_at":"2026-02-08T23:36:50.919849-06:00","closed_at":"2026-02-08T23:36:50.919849-06:00","close_reason":"Scope expanded to universal executor architecture. Needs new bead with broader scope covering executor pattern + step args + fluent DX."}
{"id":"rival-qr7","title":"Fix StepError continue behavior - coordinator treats all failures as terminal","description":"StepError with behavior='continue' returns {status: 'failed'} from step-actor.ts:131, and workflow-coordinator.ts:155 treats ALL failed steps as terminal, stopping the workflow. The documented contract says 'continue' should let the workflow proceed past the failed step.\n\nFix: coordinator should check if the step failure originated from a StepError with behavior='continue' and proceed to the next step instead of stopping.\n\nFiles: src/rival/core/step-actor.ts, src/rival/core/workflow-coordinator.ts\nFound by: Codex review\nSeverity: High","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-08T12:29:56.188057-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:49:25.690511-06:00","closed_at":"2026-02-08T20:16:49.207244-06:00","close_reason":"Closed","labels":["bug","high-priority"]}
{"id":"rival-rms","title":"Allow reusing same step function without forcing unique explicit names","description":"Current behavior: .step(hello).step(hello) fails because inferred step names collide (\"hello\"). This was unexpected and not intended as a hard limitation.\\n\\nDesired behavior:\\n- Allow reusing the same function multiple times in a workflow without requiring manual names for each occurrence.\\n- Keep actor refs and plan node names deterministic and unique.\\n\\nPossible approaches:\\n1) Auto-disambiguate inferred duplicate names (hello, hello_2, hello_3, ...).\\n2) Keep strict unique names for explicit names, but make inferred names auto-unique only when omitted by user.\\n3) Preserve compatibility for existing workflows and error messages where user explicitly sets duplicates.\\n\\nAcceptance criteria:\\n- createWorkflow('w').step(hello).step(hello).build() succeeds.\\n- Compiled actor refs are unique and stable.\\n- Result access semantics are documented for auto-disambiguated names.\\n- Tests added for inferred duplicates and explicit-name duplicate rejection.","notes":"Implemented core RMS refactor: dual identity (`id` internal, `alias` user-facing), step object form uses `run`, forEach now object form with optional alias/id and `run`, alias auto-disambiguation (`x`, `x_2`, ...), explicit duplicate alias/id validation, compiler/coordinator/loop runtime migrated to alias-keyed results with id-aware callback keys, and runtime state now exposes node metadata in workflow coordinator getState().","status":"in_progress","priority":2,"issue_type":"feature","created_at":"2026-02-11T19:39:20.463108-06:00","created_by":"behrooz","updated_at":"2026-02-13T10:35:27.64784-06:00","labels":["dx","workflow-builder"]}
{"id":"rival-roa","title":"Function-call style step arguments + hidden compile DX","description":"Problem:\nWorkflow step authoring does not feel like normal function calls. Passing static step arguments is unintuitive (requires plan/config internals), and compile details leak into user-facing DX.\n\nGoal:\nExpose a function-call-like API where developers pass step arguments naturally, while compilation/actor internals remain hidden in the default path.\n\nTarget API shape (example):\n- defineWorkflow('lumber')\n    .step(findTree, { radius: 250, species: 'oak' })\n    .step(chopTree, { blade: 'A2' })\n    .run({ location: 'north-forest' })\n\nStep function ergonomics:\n- Support either step(ctx, args) or ctx.args pattern (choose one and document clearly).\n- Args must be serializable.\n\nScope:\n1) Builder API\n- Add first-class step args on .step(...) in fluent API.\n- Keep simple no-args step path ergonomic.\n\n2) Runtime plumbing\n- Ensure step args flow through compile/runtime to step actor execute context predictably.\n- Do not require users to manually place arguments into plan config.\n\n3) Hidden compile defaults\n- Standard user path should never require explicit compileWorkflow call.\n- compile internals may remain for advanced usage but not default docs/examples.\n\n4) Typing\n- Preserve strong TS inference for step args and input where feasible.\n- Provide clear type errors for non-serializable args.\n\n5) Tests\n- Add tests for:\n  a) static args passed to step functions correctly\n  b) args + per-run input used together\n  c) no-args steps still work\n  d) serialization guard behavior\n\n6) Docs/examples\n- Rewrite primary examples to function-call style step args.\n- Explain mental model briefly: looks like functions, runs as actors.\n\nAcceptance criteria:\n- A new user can define workflow steps with arguments without touching plan internals.\n- Primary docs/examples show no explicit compile call.\n- Step argument passing is stable, typed, and covered by tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-08T22:35:26.930367-06:00","created_by":"behrooz","updated_at":"2026-02-08T22:50:34.908932-06:00","closed_at":"2026-02-08T22:50:34.908932-06:00","close_reason":"Duplicate of rival-o0p"}
{"id":"rival-s5h","title":"Build-time workflow static analysis pass","description":"Add compiler-time validations for common workflow correctness issues (unreachable branches, missing error handling hooks where required, invalid data-flow assumptions). Position as DX guardrail, not runtime replacement.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-12T11:15:15.800166-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:15:15.800166-06:00"}
{"id":"rival-sm8","title":"Remove '__' naming ban and replace with robust actor-ref encoding","description":"Current builder behavior rejects step/loop names containing '__' because it is used as an internal namespace separator. This is an unexpected developer-facing limitation and should be removed.\\n\\nProblem:\\n- WorkflowBuilder._assertUniqueStepName currently throws if name contains '__'.\\n- This leaks internal implementation details into public API constraints.\\n\\nGoal:\\n- Allow arbitrary user step/loop names (including '__') while preserving deterministic, collision-safe actor refs and plan execution.\\n\\nImplementation direction:\\n1) Remove '__' ban from builder-level validation.\\n2) Introduce a robust actor-ref encoding scheme that does not rely on raw name concatenation (e.g., escaping, length-prefixed segments, or hash+metadata approach).\\n3) Keep refs deterministic across compile runs.\\n4) Preserve readability where possible (debug metadata/logs can show original names even if encoded refs are opaque).\\n5) Add migration/compat notes if actor-ref format changes impact persisted state.\\n\\nAcceptance criteria:\\n- Names with '__' are accepted in .step and .forEach.\\n- No actor ref collisions occur due to separators appearing in user names.\\n- Existing uniqueness checks still enforce semantic duplicate names per scope.\\n- Tests added for names containing '__' at top-level and nested loops.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-11T19:53:53.907513-06:00","created_by":"behrooz","updated_at":"2026-02-11T19:53:53.907513-06:00","labels":["compiler","dx","naming"]}
{"id":"rival-tuo","title":"Add if/conditional branch step","description":"Add conditional branching (if/else) to the workflow DSL. This allows workflows to take different paths based on runtime conditions — e.g., evaluating step outputs, state values, or expressions to decide which branch to execute next. Should integrate with the existing step orchestration and actor model patterns.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-10T11:10:57.041049-06:00","created_by":"behrooz","updated_at":"2026-02-10T11:10:57.041049-06:00"}
{"id":"rival-u2e","title":"Add comprehensive test coverage for missing semantics","description":"Current test suite misses critical semantic paths:\n\n- No tests for StepError.behavior === 'continue' (workflow should proceed)\n- No tests for duplicate step names (should error at build/compile time)\n- No tests for cancellation during execution (race condition)\n- No tests for workflow rerun with stale state\n- Tests are script-style (process.exit) rather than granular bun:test cases\n\nFix: Add focused test cases for each semantic gap. Consider migrating to bun test framework with describe/it/expect for better isolation and reporting.\n\nFiles: test/\nDepends on: rival-qr7, rival-5tw, rival-0wx, rival-988\nFound by: Codex review\nSeverity: Medium","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:35.543452-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:35.543452-06:00","labels":["enhancement","testing"],"dependencies":[{"issue_id":"rival-u2e","depends_on_id":"rival-qr7","type":"blocks","created_at":"2026-02-08T12:30:57.640795-06:00","created_by":"behrooz"},{"issue_id":"rival-u2e","depends_on_id":"rival-5tw","type":"blocks","created_at":"2026-02-08T12:30:57.740822-06:00","created_by":"behrooz"},{"issue_id":"rival-u2e","depends_on_id":"rival-0wx","type":"blocks","created_at":"2026-02-08T12:30:57.850232-06:00","created_by":"behrooz"},{"issue_id":"rival-u2e","depends_on_id":"rival-988","type":"blocks","created_at":"2026-02-08T12:30:57.945419-06:00","created_by":"behrooz"}]}
{"id":"rival-uic","title":"First-class subworkflow invocation","description":"Add first-class fluent subworkflow invocation to the workflow DSL for reusable workflow composition.\n\nTarget DSL ergonomics:\n- .subworkflow(\"payment\", paymentWorkflow)\n- .subworkflow(\"payment\", paymentWorkflow, {\n    input: (ctx) =\u003e ({ orderId: ctx.input.orderId, total: ctx.stepResults.quote.total }),\n    mapResult: (subResult, ctx) =\u003e ({ paymentId: subResult?.id })\n  })\n- Should compose naturally with branching/parallel blocks.\n\nExecution model requirements (Rivet/actor strict):\n- Subworkflow execution is actor-to-actor callback/message-driven (no blocking polling loop inside actions).\n- Parent coordinator tracks active subworkflow ref/key/token and resumes on callback.\n- Cancellation propagates parent -\u003e subworkflow coordinator (best effort) and preserves terminal consistency.\n\nSemantics:\n- Subworkflow node behaves like a named step from parent perspective.\n- Parent context isolation: child receives mapped input + metadata, not full mutable parent state.\n- Child result/error mapped back into parent stepResults under subworkflow node name.\n- Timeout/error policy is explicit: inherit parent defaults unless overridden on node config.\n\nAcceptance criteria:\n1) Fluent builder API for subworkflow invocation with optional input/result mapping.\n2) Compiler emits subworkflow plan node with stable actor refs and typed contract.\n3) Runtime executes subworkflow via callback-driven coordinator orchestration.\n4) Tests: success, failure propagation, timeout/cancel propagation, nested subworkflow under loop/branch/parallel.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-12T11:14:03.523635-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:19:57.310343-06:00"}
{"id":"rival-v4n","title":"Human-in-the-loop task step type","description":"Add manual approval/task step with assignee metadata, timeout/escalation policy, and resume callback path. Include storage model for pending human tasks and cancellation handling.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-12T11:14:34.492975-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:14:34.492975-06:00"}
{"id":"rival-y5z","title":"Fix test environment - RivetKit EPERM on inspector token write","description":"Tests fail with EPERM when RivetKit tries to write inspector token to ~/Library/Application Support/rivetkit/.../inspector-token. This is the actual root cause of the test failures (not a c.client() API issue as initially suspected).\n\nTests pass when run with HOME=/tmp.\n\nFix: Configure test setup to override RivetKit storage path, or add a test helper that sets up a temp directory. This makes tests portable and CI-friendly.\n\nFiles: test/phase1.test.ts, test/phase2.test.ts, test/phase3.test.ts, test/phase4.test.ts\nFound by: Codex test run\nSeverity: Medium","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-08T12:30:28.199912-06:00","created_by":"behrooz","updated_at":"2026-02-08T12:30:28.199912-06:00","labels":["bug","testing"]}
{"id":"rival-ykl","title":"Named checkpoints and pause/resume controls","description":"Add explicit checkpoint nodes and workflow control APIs: pause, resume, and resume-from-checkpoint. Clarify runtime persistence vs user-directed resume UX and provide deterministic resume semantics.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-12T11:14:13.840123-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:14:13.840123-06:00"}
{"id":"rival-z25","title":"Built-in compensation (saga) primitives","description":"Add declarative compensation hooks for steps and automated compensation execution policies on failure. Keep actor boundaries explicit and test failure ordering/idempotency.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-12T11:14:24.175639-06:00","created_by":"behrooz","updated_at":"2026-02-12T11:14:24.175639-06:00"}
{"id":"rival-zpt","title":"Add loop step","description":"Add a loop step to the workflow; this appears to be missing and should be implemented/documented where the flow is defined.","notes":"Implementation requirement: match our existing workflow patterns using the actor model. The loop step should be orchestrated as actors that spin up, then advance to the next actor when completion messages return. Also support a fan-out/fan-in style mode (fire all, then collect/aggregate completions) where appropriate.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-09T23:09:25.281552-06:00","created_by":"behrooz","updated_at":"2026-02-09T23:11:30.286622-06:00"}
